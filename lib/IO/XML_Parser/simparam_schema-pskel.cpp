// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "simparam_schema-pskel.h"

// posV_pskel
//

void posV_pskel::
x_parser (::xml_schema::double_pskel& p)
{
  this->x_parser_ = &p;
}

void posV_pskel::
y_parser (::xml_schema::double_pskel& p)
{
  this->y_parser_ = &p;
}

void posV_pskel::
z_parser (::xml_schema::double_pskel& p)
{
  this->z_parser_ = &p;
}

void posV_pskel::
name_parser (::xml_schema::string_pskel& p)
{
  this->name_parser_ = &p;
}

void posV_pskel::
unit_parser (::xml_schema::string_pskel& p)
{
  this->unit_parser_ = &p;
}

void posV_pskel::
parsers (::xml_schema::double_pskel& x,
         ::xml_schema::double_pskel& y,
         ::xml_schema::double_pskel& z,
         ::xml_schema::string_pskel& name,
         ::xml_schema::string_pskel& unit)
{
  this->x_parser_ = &x;
  this->y_parser_ = &y;
  this->z_parser_ = &z;
  this->name_parser_ = &name;
  this->unit_parser_ = &unit;
}

posV_pskel::
posV_pskel ()
: x_parser_ (0),
  y_parser_ (0),
  z_parser_ (0),
  name_parser_ (0),
  unit_parser_ (0)
{
}

// velV_pskel
//

void velV_pskel::
vx_parser (::xml_schema::double_pskel& p)
{
  this->vx_parser_ = &p;
}

void velV_pskel::
vy_parser (::xml_schema::double_pskel& p)
{
  this->vy_parser_ = &p;
}

void velV_pskel::
vz_parser (::xml_schema::double_pskel& p)
{
  this->vz_parser_ = &p;
}

void velV_pskel::
name_parser (::xml_schema::string_pskel& p)
{
  this->name_parser_ = &p;
}

void velV_pskel::
unit_parser (::xml_schema::string_pskel& p)
{
  this->unit_parser_ = &p;
}

void velV_pskel::
parsers (::xml_schema::double_pskel& vx,
         ::xml_schema::double_pskel& vy,
         ::xml_schema::double_pskel& vz,
         ::xml_schema::string_pskel& name,
         ::xml_schema::string_pskel& unit)
{
  this->vx_parser_ = &vx;
  this->vy_parser_ = &vy;
  this->vz_parser_ = &vz;
  this->name_parser_ = &name;
  this->unit_parser_ = &unit;
}

velV_pskel::
velV_pskel ()
: vx_parser_ (0),
  vy_parser_ (0),
  vz_parser_ (0),
  name_parser_ (0),
  unit_parser_ (0)
{
}

// Vector_pskel
//

void Vector_pskel::
x_parser (::xml_schema::double_pskel& p)
{
  this->x_parser_ = &p;
}

void Vector_pskel::
y_parser (::xml_schema::double_pskel& p)
{
  this->y_parser_ = &p;
}

void Vector_pskel::
z_parser (::xml_schema::double_pskel& p)
{
  this->z_parser_ = &p;
}

void Vector_pskel::
name_parser (::xml_schema::string_pskel& p)
{
  this->name_parser_ = &p;
}

void Vector_pskel::
unit_parser (::xml_schema::string_pskel& p)
{
  this->unit_parser_ = &p;
}

void Vector_pskel::
parsers (::xml_schema::double_pskel& x,
         ::xml_schema::double_pskel& y,
         ::xml_schema::double_pskel& z,
         ::xml_schema::string_pskel& name,
         ::xml_schema::string_pskel& unit)
{
  this->x_parser_ = &x;
  this->y_parser_ = &y;
  this->z_parser_ = &z;
  this->name_parser_ = &name;
  this->unit_parser_ = &unit;
}

Vector_pskel::
Vector_pskel ()
: x_parser_ (0),
  y_parser_ (0),
  z_parser_ (0),
  name_parser_ (0),
  unit_parser_ (0)
{
}

// RotationMatrix_3x3_pskel
//

void RotationMatrix_3x3_pskel::
m11_parser (::xml_schema::double_pskel& p)
{
  this->m11_parser_ = &p;
}

void RotationMatrix_3x3_pskel::
m12_parser (::xml_schema::double_pskel& p)
{
  this->m12_parser_ = &p;
}

void RotationMatrix_3x3_pskel::
m13_parser (::xml_schema::double_pskel& p)
{
  this->m13_parser_ = &p;
}

void RotationMatrix_3x3_pskel::
m21_parser (::xml_schema::double_pskel& p)
{
  this->m21_parser_ = &p;
}

void RotationMatrix_3x3_pskel::
m22_parser (::xml_schema::double_pskel& p)
{
  this->m22_parser_ = &p;
}

void RotationMatrix_3x3_pskel::
m23_parser (::xml_schema::double_pskel& p)
{
  this->m23_parser_ = &p;
}

void RotationMatrix_3x3_pskel::
m31_parser (::xml_schema::double_pskel& p)
{
  this->m31_parser_ = &p;
}

void RotationMatrix_3x3_pskel::
m32_parser (::xml_schema::double_pskel& p)
{
  this->m32_parser_ = &p;
}

void RotationMatrix_3x3_pskel::
m33_parser (::xml_schema::double_pskel& p)
{
  this->m33_parser_ = &p;
}

void RotationMatrix_3x3_pskel::
name_parser (::xml_schema::string_pskel& p)
{
  this->name_parser_ = &p;
}

void RotationMatrix_3x3_pskel::
parsers (::xml_schema::double_pskel& m11,
         ::xml_schema::double_pskel& m12,
         ::xml_schema::double_pskel& m13,
         ::xml_schema::double_pskel& m21,
         ::xml_schema::double_pskel& m22,
         ::xml_schema::double_pskel& m23,
         ::xml_schema::double_pskel& m31,
         ::xml_schema::double_pskel& m32,
         ::xml_schema::double_pskel& m33,
         ::xml_schema::string_pskel& name)
{
  this->m11_parser_ = &m11;
  this->m12_parser_ = &m12;
  this->m13_parser_ = &m13;
  this->m21_parser_ = &m21;
  this->m22_parser_ = &m22;
  this->m23_parser_ = &m23;
  this->m31_parser_ = &m31;
  this->m32_parser_ = &m32;
  this->m33_parser_ = &m33;
  this->name_parser_ = &name;
}

RotationMatrix_3x3_pskel::
RotationMatrix_3x3_pskel ()
: m11_parser_ (0),
  m12_parser_ (0),
  m13_parser_ (0),
  m21_parser_ (0),
  m22_parser_ (0),
  m23_parser_ (0),
  m31_parser_ (0),
  m32_parser_ (0),
  m33_parser_ (0),
  name_parser_ (0)
{
}

// Dimensioned_pskel
//

void Dimensioned_pskel::
unit_parser (::xml_schema::string_pskel& p)
{
  this->unit_parser_ = &p;
}

void Dimensioned_pskel::
parsers (::xml_schema::string_pskel& unit)
{
  this->unit_parser_ = &unit;
}

Dimensioned_pskel::
Dimensioned_pskel ()
: unit_parser_ (0)
{
}

// Angle_pskel
//

void Angle_pskel::
unit_parser (::AngleType_pskel& p)
{
  this->unit_parser_ = &p;
}

void Angle_pskel::
parsers (::AngleType_pskel& unit)
{
  this->unit_parser_ = &unit;
}

Angle_pskel::
Angle_pskel ()
: unit_parser_ (0)
{
}

// Altitude_pskel
//

void Altitude_pskel::
unit_parser (::LengthType_pskel& p)
{
  this->unit_parser_ = &p;
}

void Altitude_pskel::
parsers (::LengthType_pskel& unit)
{
  this->unit_parser_ = &unit;
}

Altitude_pskel::
Altitude_pskel ()
: unit_parser_ (0)
{
}

// MoI_pskel
//

void MoI_pskel::
unit_parser (::InertiaType_pskel& p)
{
  this->unit_parser_ = &p;
}

void MoI_pskel::
parsers (::InertiaType_pskel& unit)
{
  this->unit_parser_ = &unit;
}

MoI_pskel::
MoI_pskel ()
: unit_parser_ (0)
{
}

// Mass_pskel
//

void Mass_pskel::
unit_parser (::MassType_pskel& p)
{
  this->unit_parser_ = &p;
}

void Mass_pskel::
parsers (::MassType_pskel& unit)
{
  this->unit_parser_ = &unit;
}

Mass_pskel::
Mass_pskel ()
: unit_parser_ (0)
{
}

// simparam_pskel
//

void simparam_pskel::
fileheader_parser (::fileheader_pskel& p)
{
  this->fileheader_parser_ = &p;
}

void simparam_pskel::
SC_Faces_parser (::SC_Faces_pskel& p)
{
  this->SC_Faces_parser_ = &p;
}

void simparam_pskel::
SC_properties_parser (::SC_properties_pskel& p)
{
  this->SC_properties_parser_ = &p;
}

void simparam_pskel::
InputFiles_parser (::InputFiles_pskel& p)
{
  this->InputFiles_parser_ = &p;
}

void simparam_pskel::
OutputFiles_parser (::OutputFiles_pskel& p)
{
  this->OutputFiles_parser_ = &p;
}

void simparam_pskel::
SimParameters_parser (::SimParameters_pskel& p)
{
  this->SimParameters_parser_ = &p;
}

void simparam_pskel::
SensorsActuators_parser (::SensorsActuators_pskel& p)
{
  this->SensorsActuators_parser_ = &p;
}

void simparam_pskel::
Maneuvers_parser (::Maneuvers_pskel& p)
{
  this->Maneuvers_parser_ = &p;
}

void simparam_pskel::
name_parser (::xml_schema::string_pskel& p)
{
  this->name_parser_ = &p;
}

void simparam_pskel::
parsers (::fileheader_pskel& fileheader,
         ::SC_Faces_pskel& SC_Faces,
         ::SC_properties_pskel& SC_properties,
         ::InputFiles_pskel& InputFiles,
         ::OutputFiles_pskel& OutputFiles,
         ::SimParameters_pskel& SimParameters,
         ::SensorsActuators_pskel& SensorsActuators,
         ::Maneuvers_pskel& Maneuvers,
         ::xml_schema::string_pskel& name)
{
  this->fileheader_parser_ = &fileheader;
  this->SC_Faces_parser_ = &SC_Faces;
  this->SC_properties_parser_ = &SC_properties;
  this->InputFiles_parser_ = &InputFiles;
  this->OutputFiles_parser_ = &OutputFiles;
  this->SimParameters_parser_ = &SimParameters;
  this->SensorsActuators_parser_ = &SensorsActuators;
  this->Maneuvers_parser_ = &Maneuvers;
  this->name_parser_ = &name;
}

simparam_pskel::
simparam_pskel ()
: fileheader_parser_ (0),
  SC_Faces_parser_ (0),
  SC_properties_parser_ (0),
  InputFiles_parser_ (0),
  OutputFiles_parser_ (0),
  SimParameters_parser_ (0),
  SensorsActuators_parser_ (0),
  Maneuvers_parser_ (0),
  name_parser_ (0)
{
}

// eventsparam_pskel
//

void eventsparam_pskel::
fileheader_parser (::fileheader_pskel& p)
{
  this->fileheader_parser_ = &p;
}

void eventsparam_pskel::
CompParameters_parser (::CompParameters_pskel& p)
{
  this->CompParameters_parser_ = &p;
}

void eventsparam_pskel::
TGs_parser (::TGs_pskel& p)
{
  this->TGs_parser_ = &p;
}

void eventsparam_pskel::
GSs_parser (::GSs_pskel& p)
{
  this->GSs_parser_ = &p;
}

void eventsparam_pskel::
EventsInputFiles_parser (::EventsInputFiles_pskel& p)
{
  this->EventsInputFiles_parser_ = &p;
}

void eventsparam_pskel::
EventsOutputFiles_parser (::EventsOutputFiles_pskel& p)
{
  this->EventsOutputFiles_parser_ = &p;
}

void eventsparam_pskel::
name_parser (::xml_schema::string_pskel& p)
{
  this->name_parser_ = &p;
}

void eventsparam_pskel::
parsers (::fileheader_pskel& fileheader,
         ::CompParameters_pskel& CompParameters,
         ::TGs_pskel& TGs,
         ::GSs_pskel& GSs,
         ::EventsInputFiles_pskel& EventsInputFiles,
         ::EventsOutputFiles_pskel& EventsOutputFiles,
         ::xml_schema::string_pskel& name)
{
  this->fileheader_parser_ = &fileheader;
  this->CompParameters_parser_ = &CompParameters;
  this->TGs_parser_ = &TGs;
  this->GSs_parser_ = &GSs;
  this->EventsInputFiles_parser_ = &EventsInputFiles;
  this->EventsOutputFiles_parser_ = &EventsOutputFiles;
  this->name_parser_ = &name;
}

eventsparam_pskel::
eventsparam_pskel ()
: fileheader_parser_ (0),
  CompParameters_parser_ (0),
  TGs_parser_ (0),
  GSs_parser_ (0),
  EventsInputFiles_parser_ (0),
  EventsOutputFiles_parser_ (0),
  name_parser_ (0)
{
}

// fileheader_pskel
//

void fileheader_pskel::
author_parser (::xml_schema::string_pskel& p)
{
  this->author_parser_ = &p;
}

void fileheader_pskel::
email_parser (::xml_schema::string_pskel& p)
{
  this->email_parser_ = &p;
}

void fileheader_pskel::
organization_parser (::xml_schema::string_pskel& p)
{
  this->organization_parser_ = &p;
}

void fileheader_pskel::
license_parser (::license_pskel& p)
{
  this->license_parser_ = &p;
}

void fileheader_pskel::
sensitivity_parser (::xml_schema::string_pskel& p)
{
  this->sensitivity_parser_ = &p;
}

void fileheader_pskel::
filecreationdate_parser (::xml_schema::date_pskel& p)
{
  this->filecreationdate_parser_ = &p;
}

void fileheader_pskel::
version_parser (::xml_schema::string_pskel& p)
{
  this->version_parser_ = &p;
}

void fileheader_pskel::
description_parser (::xml_schema::string_pskel& p)
{
  this->description_parser_ = &p;
}

void fileheader_pskel::
note_parser (::xml_schema::string_pskel& p)
{
  this->note_parser_ = &p;
}

void fileheader_pskel::
limitation_parser (::xml_schema::string_pskel& p)
{
  this->limitation_parser_ = &p;
}

void fileheader_pskel::
reference_parser (::reference_pskel& p)
{
  this->reference_parser_ = &p;
}

void fileheader_pskel::
parsers (::xml_schema::string_pskel& author,
         ::xml_schema::string_pskel& email,
         ::xml_schema::string_pskel& organization,
         ::license_pskel& license,
         ::xml_schema::string_pskel& sensitivity,
         ::xml_schema::date_pskel& filecreationdate,
         ::xml_schema::string_pskel& version,
         ::xml_schema::string_pskel& description,
         ::xml_schema::string_pskel& note,
         ::xml_schema::string_pskel& limitation,
         ::reference_pskel& reference)
{
  this->author_parser_ = &author;
  this->email_parser_ = &email;
  this->organization_parser_ = &organization;
  this->license_parser_ = &license;
  this->sensitivity_parser_ = &sensitivity;
  this->filecreationdate_parser_ = &filecreationdate;
  this->version_parser_ = &version;
  this->description_parser_ = &description;
  this->note_parser_ = &note;
  this->limitation_parser_ = &limitation;
  this->reference_parser_ = &reference;
}

fileheader_pskel::
fileheader_pskel ()
: author_parser_ (0),
  email_parser_ (0),
  organization_parser_ (0),
  license_parser_ (0),
  sensitivity_parser_ (0),
  filecreationdate_parser_ (0),
  version_parser_ (0),
  description_parser_ (0),
  note_parser_ (0),
  limitation_parser_ (0),
  reference_parser_ (0)
{
}

// reference_pskel
//

void reference_pskel::
author_parser (::xml_schema::string_pskel& p)
{
  this->author_parser_ = &p;
}

void reference_pskel::
date_parser (::xml_schema::string_pskel& p)
{
  this->date_parser_ = &p;
}

void reference_pskel::
refID_parser (::xml_schema::string_pskel& p)
{
  this->refID_parser_ = &p;
}

void reference_pskel::
title_parser (::xml_schema::string_pskel& p)
{
  this->title_parser_ = &p;
}

void reference_pskel::
parsers (::xml_schema::string_pskel& author,
         ::xml_schema::string_pskel& date,
         ::xml_schema::string_pskel& refID,
         ::xml_schema::string_pskel& title)
{
  this->author_parser_ = &author;
  this->date_parser_ = &date;
  this->refID_parser_ = &refID;
  this->title_parser_ = &title;
}

reference_pskel::
reference_pskel ()
: author_parser_ (0),
  date_parser_ (0),
  refID_parser_ (0),
  title_parser_ (0)
{
}

// Versor_pskel
//

void Versor_pskel::
x_parser (::xml_schema::double_pskel& p)
{
  this->x_parser_ = &p;
}

void Versor_pskel::
y_parser (::xml_schema::double_pskel& p)
{
  this->y_parser_ = &p;
}

void Versor_pskel::
z_parser (::xml_schema::double_pskel& p)
{
  this->z_parser_ = &p;
}

void Versor_pskel::
name_parser (::xml_schema::string_pskel& p)
{
  this->name_parser_ = &p;
}

void Versor_pskel::
parsers (::xml_schema::double_pskel& x,
         ::xml_schema::double_pskel& y,
         ::xml_schema::double_pskel& z,
         ::xml_schema::string_pskel& name)
{
  this->x_parser_ = &x;
  this->y_parser_ = &y;
  this->z_parser_ = &z;
  this->name_parser_ = &name;
}

Versor_pskel::
Versor_pskel ()
: x_parser_ (0),
  y_parser_ (0),
  z_parser_ (0),
  name_parser_ (0)
{
}

// SC_Faces_pskel
//

void SC_Faces_pskel::
Face_parser (::Face_pskel& p)
{
  this->Face_parser_ = &p;
}

void SC_Faces_pskel::
parsers (::Face_pskel& Face)
{
  this->Face_parser_ = &Face;
}

SC_Faces_pskel::
SC_Faces_pskel ()
: Face_parser_ (0)
{
}

// Face_pskel
//

void Face_pskel::
Area_parser (::Area_pskel& p)
{
  this->Area_parser_ = &p;
}

void Face_pskel::
Versor_parser (::Versor_pskel& p)
{
  this->Versor_parser_ = &p;
}

void Face_pskel::
Material_parser (::xml_schema::string_pskel& p)
{
  this->Material_parser_ = &p;
}

void Face_pskel::
cP_position_parser (::posV_pskel& p)
{
  this->cP_position_parser_ = &p;
}

void Face_pskel::
cA_position_parser (::posV_pskel& p)
{
  this->cA_position_parser_ = &p;
}

void Face_pskel::
name_parser (::xml_schema::string_pskel& p)
{
  this->name_parser_ = &p;
}

void Face_pskel::
parsers (::Area_pskel& Area,
         ::Versor_pskel& Versor,
         ::xml_schema::string_pskel& Material,
         ::posV_pskel& cP_position,
         ::posV_pskel& cA_position,
         ::xml_schema::string_pskel& name)
{
  this->Area_parser_ = &Area;
  this->Versor_parser_ = &Versor;
  this->Material_parser_ = &Material;
  this->cP_position_parser_ = &cP_position;
  this->cA_position_parser_ = &cA_position;
  this->name_parser_ = &name;
}

Face_pskel::
Face_pskel ()
: Area_parser_ (0),
  Versor_parser_ (0),
  Material_parser_ (0),
  cP_position_parser_ (0),
  cA_position_parser_ (0),
  name_parser_ (0)
{
}

// Length_pskel
//

void Length_pskel::
unit_parser (::LengthType_pskel& p)
{
  this->unit_parser_ = &p;
}

void Length_pskel::
parsers (::LengthType_pskel& unit)
{
  this->unit_parser_ = &unit;
}

Length_pskel::
Length_pskel ()
: unit_parser_ (0)
{
}

// Area_pskel
//

void Area_pskel::
unit_parser (::AreaType_pskel& p)
{
  this->unit_parser_ = &p;
}

void Area_pskel::
parsers (::AreaType_pskel& unit)
{
  this->unit_parser_ = &unit;
}

Area_pskel::
Area_pskel ()
: unit_parser_ (0)
{
}

// SC_properties_pskel
//

void SC_properties_pskel::
InertiaMatrix_parser (::InertiaMatrix_pskel& p)
{
  this->InertiaMatrix_parser_ = &p;
}

void SC_properties_pskel::
CoG_parser (::CoG_pskel& p)
{
  this->CoG_parser_ = &p;
}

void SC_properties_pskel::
Coefficients_parser (::Coefficients_pskel& p)
{
  this->Coefficients_parser_ = &p;
}

void SC_properties_pskel::
Areas_parser (::Areas_pskel& p)
{
  this->Areas_parser_ = &p;
}

void SC_properties_pskel::
SC_dipole_parser (::posV_pskel& p)
{
  this->SC_dipole_parser_ = &p;
}

void SC_properties_pskel::
parsers (::InertiaMatrix_pskel& InertiaMatrix,
         ::CoG_pskel& CoG,
         ::Coefficients_pskel& Coefficients,
         ::Areas_pskel& Areas,
         ::posV_pskel& SC_dipole)
{
  this->InertiaMatrix_parser_ = &InertiaMatrix;
  this->CoG_parser_ = &CoG;
  this->Coefficients_parser_ = &Coefficients;
  this->Areas_parser_ = &Areas;
  this->SC_dipole_parser_ = &SC_dipole;
}

SC_properties_pskel::
SC_properties_pskel ()
: InertiaMatrix_parser_ (0),
  CoG_parser_ (0),
  Coefficients_parser_ (0),
  Areas_parser_ (0),
  SC_dipole_parser_ (0)
{
}

// InertiaMatrix_pskel
//

void InertiaMatrix_pskel::
Ixx_parser (::MoI_pskel& p)
{
  this->Ixx_parser_ = &p;
}

void InertiaMatrix_pskel::
Iyy_parser (::MoI_pskel& p)
{
  this->Iyy_parser_ = &p;
}

void InertiaMatrix_pskel::
Izz_parser (::MoI_pskel& p)
{
  this->Izz_parser_ = &p;
}

void InertiaMatrix_pskel::
Ixy_parser (::xml_schema::double_pskel& p)
{
  this->Ixy_parser_ = &p;
}

void InertiaMatrix_pskel::
Ixz_parser (::xml_schema::double_pskel& p)
{
  this->Ixz_parser_ = &p;
}

void InertiaMatrix_pskel::
Iyz_parser (::xml_schema::double_pskel& p)
{
  this->Iyz_parser_ = &p;
}

void InertiaMatrix_pskel::
unit_parser (::InertiaType_pskel& p)
{
  this->unit_parser_ = &p;
}

void InertiaMatrix_pskel::
parsers (::MoI_pskel& Ixx,
         ::MoI_pskel& Iyy,
         ::MoI_pskel& Izz,
         ::xml_schema::double_pskel& Ixy,
         ::xml_schema::double_pskel& Ixz,
         ::xml_schema::double_pskel& Iyz,
         ::InertiaType_pskel& unit)
{
  this->Ixx_parser_ = &Ixx;
  this->Iyy_parser_ = &Iyy;
  this->Izz_parser_ = &Izz;
  this->Ixy_parser_ = &Ixy;
  this->Ixz_parser_ = &Ixz;
  this->Iyz_parser_ = &Iyz;
  this->unit_parser_ = &unit;
}

InertiaMatrix_pskel::
InertiaMatrix_pskel ()
: Ixx_parser_ (0),
  Iyy_parser_ (0),
  Izz_parser_ (0),
  Ixy_parser_ (0),
  Ixz_parser_ (0),
  Iyz_parser_ (0),
  unit_parser_ (0)
{
}

// CoG_pskel
//

void CoG_pskel::
SC_mass_parser (::Mass_pskel& p)
{
  this->SC_mass_parser_ = &p;
}

void CoG_pskel::
CoG_pos_parser (::posV_pskel& p)
{
  this->CoG_pos_parser_ = &p;
}

void CoG_pskel::
parsers (::Mass_pskel& SC_mass,
         ::posV_pskel& CoG_pos)
{
  this->SC_mass_parser_ = &SC_mass;
  this->CoG_pos_parser_ = &CoG_pos;
}

CoG_pskel::
CoG_pskel ()
: SC_mass_parser_ (0),
  CoG_pos_parser_ (0)
{
}

// Coefficients_pskel
//

void Coefficients_pskel::
Cd_parser (::PositiveNumber_pskel& p)
{
  this->Cd_parser_ = &p;
}

void Coefficients_pskel::
Cr_parser (::PositiveNumber_pskel& p)
{
  this->Cr_parser_ = &p;
}

void Coefficients_pskel::
parsers (::PositiveNumber_pskel& Cd,
         ::PositiveNumber_pskel& Cr)
{
  this->Cd_parser_ = &Cd;
  this->Cr_parser_ = &Cr;
}

Coefficients_pskel::
Coefficients_pskel ()
: Cd_parser_ (0),
  Cr_parser_ (0)
{
}

// Areas_pskel
//

void Areas_pskel::
Area_D_parser (::PositiveNumber_pskel& p)
{
  this->Area_D_parser_ = &p;
}

void Areas_pskel::
Area_R_parser (::PositiveNumber_pskel& p)
{
  this->Area_R_parser_ = &p;
}

void Areas_pskel::
parsers (::PositiveNumber_pskel& Area_D,
         ::PositiveNumber_pskel& Area_R)
{
  this->Area_D_parser_ = &Area_D;
  this->Area_R_parser_ = &Area_R;
}

Areas_pskel::
Areas_pskel ()
: Area_D_parser_ (0),
  Area_R_parser_ (0)
{
}

// SimParameters_pskel
//

void SimParameters_pskel::
durstep_parser (::durstep_pskel& p)
{
  this->durstep_parser_ = &p;
}

void SimParameters_pskel::
ORB_initstate_parser (::ORB_initstate_pskel& p)
{
  this->ORB_initstate_parser_ = &p;
}

void SimParameters_pskel::
ATT_initstate_parser (::ATT_initstate_pskel& p)
{
  this->ATT_initstate_parser_ = &p;
}

void SimParameters_pskel::
simoptions_parser (::simoptions_pskel& p)
{
  this->simoptions_parser_ = &p;
}

void SimParameters_pskel::
parsers (::durstep_pskel& durstep,
         ::ORB_initstate_pskel& ORB_initstate,
         ::ATT_initstate_pskel& ATT_initstate,
         ::simoptions_pskel& simoptions)
{
  this->durstep_parser_ = &durstep;
  this->ORB_initstate_parser_ = &ORB_initstate;
  this->ATT_initstate_parser_ = &ATT_initstate;
  this->simoptions_parser_ = &simoptions;
}

SimParameters_pskel::
SimParameters_pskel ()
: durstep_parser_ (0),
  ORB_initstate_parser_ (0),
  ATT_initstate_parser_ (0),
  simoptions_parser_ (0)
{
}

// durstep_pskel
//

void durstep_pskel::
simstep_parser (::xml_schema::duration_pskel& p)
{
  this->simstep_parser_ = &p;
}

void durstep_pskel::
simduration_parser (::xml_schema::duration_pskel& p)
{
  this->simduration_parser_ = &p;
}

void durstep_pskel::
parsers (::xml_schema::duration_pskel& simstep,
         ::xml_schema::duration_pskel& simduration)
{
  this->simstep_parser_ = &simstep;
  this->simduration_parser_ = &simduration;
}

durstep_pskel::
durstep_pskel ()
: simstep_parser_ (0),
  simduration_parser_ (0)
{
}

// ORB_initstate_pskel
//

void ORB_initstate_pskel::
Initime_parser (::xml_schema::date_time_pskel& p)
{
  this->Initime_parser_ = &p;
}

void ORB_initstate_pskel::
Position_parser (::posV_pskel& p)
{
  this->Position_parser_ = &p;
}

void ORB_initstate_pskel::
Velocity_parser (::velV_pskel& p)
{
  this->Velocity_parser_ = &p;
}

void ORB_initstate_pskel::
parsers (::xml_schema::date_time_pskel& Initime,
         ::posV_pskel& Position,
         ::velV_pskel& Velocity)
{
  this->Initime_parser_ = &Initime;
  this->Position_parser_ = &Position;
  this->Velocity_parser_ = &Velocity;
}

ORB_initstate_pskel::
ORB_initstate_pskel ()
: Initime_parser_ (0),
  Position_parser_ (0),
  Velocity_parser_ (0)
{
}

// ATT_initstate_pskel
//

void ATT_initstate_pskel::
phi_parser (::Angle_pskel& p)
{
  this->phi_parser_ = &p;
}

void ATT_initstate_pskel::
theta_parser (::Angle_pskel& p)
{
  this->theta_parser_ = &p;
}

void ATT_initstate_pskel::
psi_parser (::Angle_pskel& p)
{
  this->psi_parser_ = &p;
}

void ATT_initstate_pskel::
om_x_parser (::Angle_pskel& p)
{
  this->om_x_parser_ = &p;
}

void ATT_initstate_pskel::
om_y_parser (::Angle_pskel& p)
{
  this->om_y_parser_ = &p;
}

void ATT_initstate_pskel::
om_z_parser (::Angle_pskel& p)
{
  this->om_z_parser_ = &p;
}

void ATT_initstate_pskel::
parsers (::Angle_pskel& phi,
         ::Angle_pskel& theta,
         ::Angle_pskel& psi,
         ::Angle_pskel& om_x,
         ::Angle_pskel& om_y,
         ::Angle_pskel& om_z)
{
  this->phi_parser_ = &phi;
  this->theta_parser_ = &theta;
  this->psi_parser_ = &psi;
  this->om_x_parser_ = &om_x;
  this->om_y_parser_ = &om_y;
  this->om_z_parser_ = &om_z;
}

ATT_initstate_pskel::
ATT_initstate_pskel ()
: phi_parser_ (0),
  theta_parser_ (0),
  psi_parser_ (0),
  om_x_parser_ (0),
  om_y_parser_ (0),
  om_z_parser_ (0)
{
}

// simoptions_pskel
//

void simoptions_pskel::
initstate_in_RTN_parser (::xml_schema::boolean_pskel& p)
{
  this->initstate_in_RTN_parser_ = &p;
}

void simoptions_pskel::
realtime_parser (::xml_schema::boolean_pskel& p)
{
  this->realtime_parser_ = &p;
}

void simoptions_pskel::
realtime_wait_parser (::Dimensioned_pskel& p)
{
  this->realtime_wait_parser_ = &p;
}

void simoptions_pskel::
ggrad_on_parser (::xml_schema::boolean_pskel& p)
{
  this->ggrad_on_parser_ = &p;
}

void simoptions_pskel::
mag_on_parser (::xml_schema::boolean_pskel& p)
{
  this->mag_on_parser_ = &p;
}

void simoptions_pskel::
srp_on_parser (::xml_schema::boolean_pskel& p)
{
  this->srp_on_parser_ = &p;
}

void simoptions_pskel::
drag_on_parser (::xml_schema::boolean_pskel& p)
{
  this->drag_on_parser_ = &p;
}

void simoptions_pskel::
nMAX_parser (::nMAX_pskel& p)
{
  this->nMAX_parser_ = &p;
}

void simoptions_pskel::
sunmoon_on_parser (::xml_schema::boolean_pskel& p)
{
  this->sunmoon_on_parser_ = &p;
}

void simoptions_pskel::
Drag_Model_parser (::xml_schema::string_pskel& p)
{
  this->Drag_Model_parser_ = &p;
}

void simoptions_pskel::
SRP_Model_parser (::xml_schema::string_pskel& p)
{
  this->SRP_Model_parser_ = &p;
}

void simoptions_pskel::
AttitudeType_parser (::xml_schema::string_pskel& p)
{
  this->AttitudeType_parser_ = &p;
}

void simoptions_pskel::
attctrl_on_parser (::xml_schema::boolean_pskel& p)
{
  this->attctrl_on_parser_ = &p;
}

void simoptions_pskel::
AttCtrlType_parser (::xml_schema::string_pskel& p)
{
  this->AttCtrlType_parser_ = &p;
}

void simoptions_pskel::
orbctrl_on_parser (::xml_schema::boolean_pskel& p)
{
  this->orbctrl_on_parser_ = &p;
}

void simoptions_pskel::
OrbCtrlType_parser (::xml_schema::string_pskel& p)
{
  this->OrbCtrlType_parser_ = &p;
}

void simoptions_pskel::
parsers (::xml_schema::boolean_pskel& initstate_in_RTN,
         ::xml_schema::boolean_pskel& realtime,
         ::Dimensioned_pskel& realtime_wait,
         ::xml_schema::boolean_pskel& ggrad_on,
         ::xml_schema::boolean_pskel& mag_on,
         ::xml_schema::boolean_pskel& srp_on,
         ::xml_schema::boolean_pskel& drag_on,
         ::nMAX_pskel& nMAX,
         ::xml_schema::boolean_pskel& sunmoon_on,
         ::xml_schema::string_pskel& Drag_Model,
         ::xml_schema::string_pskel& SRP_Model,
         ::xml_schema::string_pskel& AttitudeType,
         ::xml_schema::boolean_pskel& attctrl_on,
         ::xml_schema::string_pskel& AttCtrlType,
         ::xml_schema::boolean_pskel& orbctrl_on,
         ::xml_schema::string_pskel& OrbCtrlType)
{
  this->initstate_in_RTN_parser_ = &initstate_in_RTN;
  this->realtime_parser_ = &realtime;
  this->realtime_wait_parser_ = &realtime_wait;
  this->ggrad_on_parser_ = &ggrad_on;
  this->mag_on_parser_ = &mag_on;
  this->srp_on_parser_ = &srp_on;
  this->drag_on_parser_ = &drag_on;
  this->nMAX_parser_ = &nMAX;
  this->sunmoon_on_parser_ = &sunmoon_on;
  this->Drag_Model_parser_ = &Drag_Model;
  this->SRP_Model_parser_ = &SRP_Model;
  this->AttitudeType_parser_ = &AttitudeType;
  this->attctrl_on_parser_ = &attctrl_on;
  this->AttCtrlType_parser_ = &AttCtrlType;
  this->orbctrl_on_parser_ = &orbctrl_on;
  this->OrbCtrlType_parser_ = &OrbCtrlType;
}

simoptions_pskel::
simoptions_pskel ()
: initstate_in_RTN_parser_ (0),
  realtime_parser_ (0),
  realtime_wait_parser_ (0),
  ggrad_on_parser_ (0),
  mag_on_parser_ (0),
  srp_on_parser_ (0),
  drag_on_parser_ (0),
  nMAX_parser_ (0),
  sunmoon_on_parser_ (0),
  Drag_Model_parser_ (0),
  SRP_Model_parser_ (0),
  AttitudeType_parser_ (0),
  attctrl_on_parser_ (0),
  AttCtrlType_parser_ (0),
  orbctrl_on_parser_ (0),
  OrbCtrlType_parser_ (0)
{
}

// InputFiles_pskel
//

void InputFiles_pskel::
Orbit_ephemeris_parser (::xml_schema::string_pskel& p)
{
  this->Orbit_ephemeris_parser_ = &p;
}

void InputFiles_pskel::
Attitude_ephemeris_parser (::xml_schema::string_pskel& p)
{
  this->Attitude_ephemeris_parser_ = &p;
}

void InputFiles_pskel::
TLE_parser (::xml_schema::string_pskel& p)
{
  this->TLE_parser_ = &p;
}

void InputFiles_pskel::
Data_path_parser (::xml_schema::string_pskel& p)
{
  this->Data_path_parser_ = &p;
}

void InputFiles_pskel::
Planet_ephemeris_parser (::xml_schema::string_pskel& p)
{
  this->Planet_ephemeris_parser_ = &p;
}

void InputFiles_pskel::
EOP_parameters_parser (::xml_schema::string_pskel& p)
{
  this->EOP_parameters_parser_ = &p;
}

void InputFiles_pskel::
PCK_data_parser (::xml_schema::string_pskel& p)
{
  this->PCK_data_parser_ = &p;
}

void InputFiles_pskel::
Leap_second_parser (::xml_schema::string_pskel& p)
{
  this->Leap_second_parser_ = &p;
}

void InputFiles_pskel::
Gravity_model_parser (::xml_schema::string_pskel& p)
{
  this->Gravity_model_parser_ = &p;
}

void InputFiles_pskel::
Atmospheric_model_parser (::xml_schema::string_pskel& p)
{
  this->Atmospheric_model_parser_ = &p;
}

void InputFiles_pskel::
Magnetic_model_parser (::xml_schema::string_pskel& p)
{
  this->Magnetic_model_parser_ = &p;
}

void InputFiles_pskel::
SunMoon_model_parser (::xml_schema::string_pskel& p)
{
  this->SunMoon_model_parser_ = &p;
}

void InputFiles_pskel::
name_parser (::xml_schema::string_pskel& p)
{
  this->name_parser_ = &p;
}

void InputFiles_pskel::
parsers (::xml_schema::string_pskel& Orbit_ephemeris,
         ::xml_schema::string_pskel& Attitude_ephemeris,
         ::xml_schema::string_pskel& TLE,
         ::xml_schema::string_pskel& Data_path,
         ::xml_schema::string_pskel& Planet_ephemeris,
         ::xml_schema::string_pskel& EOP_parameters,
         ::xml_schema::string_pskel& PCK_data,
         ::xml_schema::string_pskel& Leap_second,
         ::xml_schema::string_pskel& Gravity_model,
         ::xml_schema::string_pskel& Atmospheric_model,
         ::xml_schema::string_pskel& Magnetic_model,
         ::xml_schema::string_pskel& SunMoon_model,
         ::xml_schema::string_pskel& name)
{
  this->Orbit_ephemeris_parser_ = &Orbit_ephemeris;
  this->Attitude_ephemeris_parser_ = &Attitude_ephemeris;
  this->TLE_parser_ = &TLE;
  this->Data_path_parser_ = &Data_path;
  this->Planet_ephemeris_parser_ = &Planet_ephemeris;
  this->EOP_parameters_parser_ = &EOP_parameters;
  this->PCK_data_parser_ = &PCK_data;
  this->Leap_second_parser_ = &Leap_second;
  this->Gravity_model_parser_ = &Gravity_model;
  this->Atmospheric_model_parser_ = &Atmospheric_model;
  this->Magnetic_model_parser_ = &Magnetic_model;
  this->SunMoon_model_parser_ = &SunMoon_model;
  this->name_parser_ = &name;
}

InputFiles_pskel::
InputFiles_pskel ()
: Orbit_ephemeris_parser_ (0),
  Attitude_ephemeris_parser_ (0),
  TLE_parser_ (0),
  Data_path_parser_ (0),
  Planet_ephemeris_parser_ (0),
  EOP_parameters_parser_ (0),
  PCK_data_parser_ (0),
  Leap_second_parser_ (0),
  Gravity_model_parser_ (0),
  Atmospheric_model_parser_ (0),
  Magnetic_model_parser_ (0),
  SunMoon_model_parser_ (0),
  name_parser_ (0)
{
}

// OutputFiles_pskel
//

void OutputFiles_pskel::
Orbit_ephemeris_parser (::xml_schema::string_pskel& p)
{
  this->Orbit_ephemeris_parser_ = &p;
}

void OutputFiles_pskel::
Attitude_ephemeris_parser (::xml_schema::string_pskel& p)
{
  this->Attitude_ephemeris_parser_ = &p;
}

void OutputFiles_pskel::
Sensor_output_parser (::xml_schema::string_pskel& p)
{
  this->Sensor_output_parser_ = &p;
}

void OutputFiles_pskel::
Torques_parser (::xml_schema::string_pskel& p)
{
  this->Torques_parser_ = &p;
}

void OutputFiles_pskel::
Accelerations_parser (::xml_schema::string_pskel& p)
{
  this->Accelerations_parser_ = &p;
}

void OutputFiles_pskel::
name_parser (::xml_schema::string_pskel& p)
{
  this->name_parser_ = &p;
}

void OutputFiles_pskel::
parsers (::xml_schema::string_pskel& Orbit_ephemeris,
         ::xml_schema::string_pskel& Attitude_ephemeris,
         ::xml_schema::string_pskel& Sensor_output,
         ::xml_schema::string_pskel& Torques,
         ::xml_schema::string_pskel& Accelerations,
         ::xml_schema::string_pskel& name)
{
  this->Orbit_ephemeris_parser_ = &Orbit_ephemeris;
  this->Attitude_ephemeris_parser_ = &Attitude_ephemeris;
  this->Sensor_output_parser_ = &Sensor_output;
  this->Torques_parser_ = &Torques;
  this->Accelerations_parser_ = &Accelerations;
  this->name_parser_ = &name;
}

OutputFiles_pskel::
OutputFiles_pskel ()
: Orbit_ephemeris_parser_ (0),
  Attitude_ephemeris_parser_ (0),
  Sensor_output_parser_ (0),
  Torques_parser_ (0),
  Accelerations_parser_ (0),
  name_parser_ (0)
{
}

// SensorsActuators_pskel
//

void SensorsActuators_pskel::
subsystem_on_parser (::xml_schema::boolean_pskel& p)
{
  this->subsystem_on_parser_ = &p;
}

void SensorsActuators_pskel::
constparam_parser (::constparam_pskel& p)
{
  this->constparam_parser_ = &p;
}

void SensorsActuators_pskel::
auxparam_parser (::auxparam_pskel& p)
{
  this->auxparam_parser_ = &p;
}

void SensorsActuators_pskel::
opslimit_parser (::opslimit_pskel& p)
{
  this->opslimit_parser_ = &p;
}

void SensorsActuators_pskel::
accuracy_parser (::accuracy_pskel& p)
{
  this->accuracy_parser_ = &p;
}

void SensorsActuators_pskel::
SC2SYS_matrix_parser (::RotationMatrix_3x3_pskel& p)
{
  this->SC2SYS_matrix_parser_ = &p;
}

void SensorsActuators_pskel::
name_parser (::xml_schema::string_pskel& p)
{
  this->name_parser_ = &p;
}

void SensorsActuators_pskel::
parsers (::xml_schema::boolean_pskel& subsystem_on,
         ::constparam_pskel& constparam,
         ::auxparam_pskel& auxparam,
         ::opslimit_pskel& opslimit,
         ::accuracy_pskel& accuracy,
         ::RotationMatrix_3x3_pskel& SC2SYS_matrix,
         ::xml_schema::string_pskel& name)
{
  this->subsystem_on_parser_ = &subsystem_on;
  this->constparam_parser_ = &constparam;
  this->auxparam_parser_ = &auxparam;
  this->opslimit_parser_ = &opslimit;
  this->accuracy_parser_ = &accuracy;
  this->SC2SYS_matrix_parser_ = &SC2SYS_matrix;
  this->name_parser_ = &name;
}

SensorsActuators_pskel::
SensorsActuators_pskel ()
: subsystem_on_parser_ (0),
  constparam_parser_ (0),
  auxparam_parser_ (0),
  opslimit_parser_ (0),
  accuracy_parser_ (0),
  SC2SYS_matrix_parser_ (0),
  name_parser_ (0)
{
}

// constparam_pskel
//

void constparam_pskel::
name_parser (::xml_schema::string_pskel& p)
{
  this->name_parser_ = &p;
}

void constparam_pskel::
unit_parser (::xml_schema::string_pskel& p)
{
  this->unit_parser_ = &p;
}

void constparam_pskel::
parsers (::xml_schema::string_pskel& name,
         ::xml_schema::string_pskel& unit)
{
  this->name_parser_ = &name;
  this->unit_parser_ = &unit;
}

constparam_pskel::
constparam_pskel ()
: name_parser_ (0),
  unit_parser_ (0)
{
}

// auxparam_pskel
//

void auxparam_pskel::
name_parser (::xml_schema::string_pskel& p)
{
  this->name_parser_ = &p;
}

void auxparam_pskel::
unit_parser (::xml_schema::string_pskel& p)
{
  this->unit_parser_ = &p;
}

void auxparam_pskel::
parsers (::xml_schema::string_pskel& name,
         ::xml_schema::string_pskel& unit)
{
  this->name_parser_ = &name;
  this->unit_parser_ = &unit;
}

auxparam_pskel::
auxparam_pskel ()
: name_parser_ (0),
  unit_parser_ (0)
{
}

// opslimit_pskel
//

void opslimit_pskel::
name_parser (::xml_schema::string_pskel& p)
{
  this->name_parser_ = &p;
}

void opslimit_pskel::
unit_parser (::xml_schema::string_pskel& p)
{
  this->unit_parser_ = &p;
}

void opslimit_pskel::
parsers (::xml_schema::string_pskel& name,
         ::xml_schema::string_pskel& unit)
{
  this->name_parser_ = &name;
  this->unit_parser_ = &unit;
}

opslimit_pskel::
opslimit_pskel ()
: name_parser_ (0),
  unit_parser_ (0)
{
}

// accuracy_pskel
//

void accuracy_pskel::
name_parser (::xml_schema::string_pskel& p)
{
  this->name_parser_ = &p;
}

void accuracy_pskel::
unit_parser (::xml_schema::string_pskel& p)
{
  this->unit_parser_ = &p;
}

void accuracy_pskel::
parsers (::xml_schema::string_pskel& name,
         ::xml_schema::string_pskel& unit)
{
  this->name_parser_ = &name;
  this->unit_parser_ = &unit;
}

accuracy_pskel::
accuracy_pskel ()
: name_parser_ (0),
  unit_parser_ (0)
{
}

// Maneuvers_pskel
//

void Maneuvers_pskel::
Man_parser (::Man_pskel& p)
{
  this->Man_parser_ = &p;
}

void Maneuvers_pskel::
parsers (::Man_pskel& Man)
{
  this->Man_parser_ = &Man;
}

Maneuvers_pskel::
Maneuvers_pskel ()
: Man_parser_ (0)
{
}

// Man_pskel
//

void Man_pskel::
maneuver_on_parser (::xml_schema::boolean_pskel& p)
{
  this->maneuver_on_parser_ = &p;
}

void Man_pskel::
init_time_parser (::xml_schema::double_pskel& p)
{
  this->init_time_parser_ = &p;
}

void Man_pskel::
duration_parser (::xml_schema::double_pskel& p)
{
  this->duration_parser_ = &p;
}

void Man_pskel::
ManVec_parser (::Vector_pskel& p)
{
  this->ManVec_parser_ = &p;
}

void Man_pskel::
name_parser (::name_pskel& p)
{
  this->name_parser_ = &p;
}

void Man_pskel::
parsers (::xml_schema::boolean_pskel& maneuver_on,
         ::xml_schema::double_pskel& init_time,
         ::xml_schema::double_pskel& duration,
         ::Vector_pskel& ManVec,
         ::name_pskel& name)
{
  this->maneuver_on_parser_ = &maneuver_on;
  this->init_time_parser_ = &init_time;
  this->duration_parser_ = &duration;
  this->ManVec_parser_ = &ManVec;
  this->name_parser_ = &name;
}

Man_pskel::
Man_pskel ()
: maneuver_on_parser_ (0),
  init_time_parser_ (0),
  duration_parser_ (0),
  ManVec_parser_ (0),
  name_parser_ (0)
{
}

// CompParameters_pskel
//

void CompParameters_pskel::
durstep_parser (::durstep_pskel& p)
{
  this->durstep_parser_ = &p;
}

void CompParameters_pskel::
Payload_parser (::Payload_pskel& p)
{
  this->Payload_parser_ = &p;
}

void CompParameters_pskel::
Spacecraft_parser (::Spacecraft_pskel& p)
{
  this->Spacecraft_parser_ = &p;
}

void CompParameters_pskel::
Compoptions_parser (::Compoptions_pskel& p)
{
  this->Compoptions_parser_ = &p;
}

void CompParameters_pskel::
parsers (::durstep_pskel& durstep,
         ::Payload_pskel& Payload,
         ::Spacecraft_pskel& Spacecraft,
         ::Compoptions_pskel& Compoptions)
{
  this->durstep_parser_ = &durstep;
  this->Payload_parser_ = &Payload;
  this->Spacecraft_parser_ = &Spacecraft;
  this->Compoptions_parser_ = &Compoptions;
}

CompParameters_pskel::
CompParameters_pskel ()
: durstep_parser_ (0),
  Payload_parser_ (0),
  Spacecraft_parser_ (0),
  Compoptions_parser_ (0)
{
}

// Payload_pskel
//

void Payload_pskel::
FOV_cross_parser (::Angle_pskel& p)
{
  this->FOV_cross_parser_ = &p;
}

void Payload_pskel::
FOV_along_parser (::Angle_pskel& p)
{
  this->FOV_along_parser_ = &p;
}

void Payload_pskel::
parsers (::Angle_pskel& FOV_cross,
         ::Angle_pskel& FOV_along)
{
  this->FOV_cross_parser_ = &FOV_cross;
  this->FOV_along_parser_ = &FOV_along;
}

Payload_pskel::
Payload_pskel ()
: FOV_cross_parser_ (0),
  FOV_along_parser_ (0)
{
}

// Spacecraft_pskel
//

void Spacecraft_pskel::
SC_start_parser (::xml_schema::positive_integer_pskel& p)
{
  this->SC_start_parser_ = &p;
}

void Spacecraft_pskel::
SC_end_parser (::xml_schema::positive_integer_pskel& p)
{
  this->SC_end_parser_ = &p;
}

void Spacecraft_pskel::
PL_start_parser (::xml_schema::positive_integer_pskel& p)
{
  this->PL_start_parser_ = &p;
}

void Spacecraft_pskel::
PL_end_parser (::xml_schema::positive_integer_pskel& p)
{
  this->PL_end_parser_ = &p;
}

void Spacecraft_pskel::
parsers (::xml_schema::positive_integer_pskel& SC_start,
         ::xml_schema::positive_integer_pskel& SC_end,
         ::xml_schema::positive_integer_pskel& PL_start,
         ::xml_schema::positive_integer_pskel& PL_end)
{
  this->SC_start_parser_ = &SC_start;
  this->SC_end_parser_ = &SC_end;
  this->PL_start_parser_ = &PL_start;
  this->PL_end_parser_ = &PL_end;
}

Spacecraft_pskel::
Spacecraft_pskel ()
: SC_start_parser_ (0),
  SC_end_parser_ (0),
  PL_start_parser_ (0),
  PL_end_parser_ (0)
{
}

// Compoptions_pskel
//

void Compoptions_pskel::
TGs_on_parser (::xml_schema::boolean_pskel& p)
{
  this->TGs_on_parser_ = &p;
}

void Compoptions_pskel::
GSs_on_parser (::xml_schema::boolean_pskel& p)
{
  this->GSs_on_parser_ = &p;
}

void Compoptions_pskel::
TGs_grid_on_parser (::xml_schema::boolean_pskel& p)
{
  this->TGs_grid_on_parser_ = &p;
}

void Compoptions_pskel::
Eclipse_on_parser (::xml_schema::boolean_pskel& p)
{
  this->Eclipse_on_parser_ = &p;
}

void Compoptions_pskel::
parsers (::xml_schema::boolean_pskel& TGs_on,
         ::xml_schema::boolean_pskel& GSs_on,
         ::xml_schema::boolean_pskel& TGs_grid_on,
         ::xml_schema::boolean_pskel& Eclipse_on)
{
  this->TGs_on_parser_ = &TGs_on;
  this->GSs_on_parser_ = &GSs_on;
  this->TGs_grid_on_parser_ = &TGs_grid_on;
  this->Eclipse_on_parser_ = &Eclipse_on;
}

Compoptions_pskel::
Compoptions_pskel ()
: TGs_on_parser_ (0),
  GSs_on_parser_ (0),
  TGs_grid_on_parser_ (0),
  Eclipse_on_parser_ (0)
{
}

// TGs_pskel
//

void TGs_pskel::
TGs_grid_parser (::TGs_grid_pskel& p)
{
  this->TGs_grid_parser_ = &p;
}

void TGs_pskel::
TGs_list_parser (::TGs_list_pskel& p)
{
  this->TGs_list_parser_ = &p;
}

void TGs_pskel::
parsers (::TGs_grid_pskel& TGs_grid,
         ::TGs_list_pskel& TGs_list)
{
  this->TGs_grid_parser_ = &TGs_grid;
  this->TGs_list_parser_ = &TGs_list;
}

TGs_pskel::
TGs_pskel ()
: TGs_grid_parser_ (0),
  TGs_list_parser_ (0)
{
}

// TGs_grid_pskel
//

void TGs_grid_pskel::
minlon_parser (::Angle_pskel& p)
{
  this->minlon_parser_ = &p;
}

void TGs_grid_pskel::
maxlon_parser (::Angle_pskel& p)
{
  this->maxlon_parser_ = &p;
}

void TGs_grid_pskel::
minlat_parser (::Angle_pskel& p)
{
  this->minlat_parser_ = &p;
}

void TGs_grid_pskel::
maxlat_parser (::Angle_pskel& p)
{
  this->maxlat_parser_ = &p;
}

void TGs_grid_pskel::
gridstep_parser (::Angle_pskel& p)
{
  this->gridstep_parser_ = &p;
}

void TGs_grid_pskel::
parsers (::Angle_pskel& minlon,
         ::Angle_pskel& maxlon,
         ::Angle_pskel& minlat,
         ::Angle_pskel& maxlat,
         ::Angle_pskel& gridstep)
{
  this->minlon_parser_ = &minlon;
  this->maxlon_parser_ = &maxlon;
  this->minlat_parser_ = &minlat;
  this->maxlat_parser_ = &maxlat;
  this->gridstep_parser_ = &gridstep;
}

TGs_grid_pskel::
TGs_grid_pskel ()
: minlon_parser_ (0),
  maxlon_parser_ (0),
  minlat_parser_ (0),
  maxlat_parser_ (0),
  gridstep_parser_ (0)
{
}

// TGs_list_pskel
//

void TGs_list_pskel::
TG_parser (::TG_pskel& p)
{
  this->TG_parser_ = &p;
}

void TGs_list_pskel::
parsers (::TG_pskel& TG)
{
  this->TG_parser_ = &TG;
}

TGs_list_pskel::
TGs_list_pskel ()
: TG_parser_ (0)
{
}

// TG_pskel
//

void TG_pskel::
lon_parser (::Angle_pskel& p)
{
  this->lon_parser_ = &p;
}

void TG_pskel::
lat_parser (::Angle_pskel& p)
{
  this->lat_parser_ = &p;
}

void TG_pskel::
alt_parser (::Altitude_pskel& p)
{
  this->alt_parser_ = &p;
}

void TG_pskel::
name_parser (::xml_schema::string_pskel& p)
{
  this->name_parser_ = &p;
}

void TG_pskel::
parsers (::Angle_pskel& lon,
         ::Angle_pskel& lat,
         ::Altitude_pskel& alt,
         ::xml_schema::string_pskel& name)
{
  this->lon_parser_ = &lon;
  this->lat_parser_ = &lat;
  this->alt_parser_ = &alt;
  this->name_parser_ = &name;
}

TG_pskel::
TG_pskel ()
: lon_parser_ (0),
  lat_parser_ (0),
  alt_parser_ (0),
  name_parser_ (0)
{
}

// GSs_pskel
//

void GSs_pskel::
GS_parser (::GS_pskel& p)
{
  this->GS_parser_ = &p;
}

void GSs_pskel::
parsers (::GS_pskel& GS)
{
  this->GS_parser_ = &GS;
}

GSs_pskel::
GSs_pskel ()
: GS_parser_ (0)
{
}

// GS_pskel
//

void GS_pskel::
lon_parser (::Angle_pskel& p)
{
  this->lon_parser_ = &p;
}

void GS_pskel::
lat_parser (::Angle_pskel& p)
{
  this->lat_parser_ = &p;
}

void GS_pskel::
alt_parser (::Altitude_pskel& p)
{
  this->alt_parser_ = &p;
}

void GS_pskel::
minelev_parser (::Angle_pskel& p)
{
  this->minelev_parser_ = &p;
}

void GS_pskel::
name_parser (::xml_schema::string_pskel& p)
{
  this->name_parser_ = &p;
}

void GS_pskel::
parsers (::Angle_pskel& lon,
         ::Angle_pskel& lat,
         ::Altitude_pskel& alt,
         ::Angle_pskel& minelev,
         ::xml_schema::string_pskel& name)
{
  this->lon_parser_ = &lon;
  this->lat_parser_ = &lat;
  this->alt_parser_ = &alt;
  this->minelev_parser_ = &minelev;
  this->name_parser_ = &name;
}

GS_pskel::
GS_pskel ()
: lon_parser_ (0),
  lat_parser_ (0),
  alt_parser_ (0),
  minelev_parser_ (0),
  name_parser_ (0)
{
}

// EventsInputFiles_pskel
//

void EventsInputFiles_pskel::
Orbit_ephemeris_path_parser (::xml_schema::string_pskel& p)
{
  this->Orbit_ephemeris_path_parser_ = &p;
}

void EventsInputFiles_pskel::
Orbit_ephemeris_rootname_parser (::xml_schema::string_pskel& p)
{
  this->Orbit_ephemeris_rootname_parser_ = &p;
}

void EventsInputFiles_pskel::
Data_path_parser (::xml_schema::string_pskel& p)
{
  this->Data_path_parser_ = &p;
}

void EventsInputFiles_pskel::
Planet_ephemeris_parser (::xml_schema::string_pskel& p)
{
  this->Planet_ephemeris_parser_ = &p;
}

void EventsInputFiles_pskel::
EOP_parameters_parser (::xml_schema::string_pskel& p)
{
  this->EOP_parameters_parser_ = &p;
}

void EventsInputFiles_pskel::
PCK_data_parser (::xml_schema::string_pskel& p)
{
  this->PCK_data_parser_ = &p;
}

void EventsInputFiles_pskel::
Leap_second_parser (::xml_schema::string_pskel& p)
{
  this->Leap_second_parser_ = &p;
}

void EventsInputFiles_pskel::
name_parser (::xml_schema::string_pskel& p)
{
  this->name_parser_ = &p;
}

void EventsInputFiles_pskel::
parsers (::xml_schema::string_pskel& Orbit_ephemeris_path,
         ::xml_schema::string_pskel& Orbit_ephemeris_rootname,
         ::xml_schema::string_pskel& Data_path,
         ::xml_schema::string_pskel& Planet_ephemeris,
         ::xml_schema::string_pskel& EOP_parameters,
         ::xml_schema::string_pskel& PCK_data,
         ::xml_schema::string_pskel& Leap_second,
         ::xml_schema::string_pskel& name)
{
  this->Orbit_ephemeris_path_parser_ = &Orbit_ephemeris_path;
  this->Orbit_ephemeris_rootname_parser_ = &Orbit_ephemeris_rootname;
  this->Data_path_parser_ = &Data_path;
  this->Planet_ephemeris_parser_ = &Planet_ephemeris;
  this->EOP_parameters_parser_ = &EOP_parameters;
  this->PCK_data_parser_ = &PCK_data;
  this->Leap_second_parser_ = &Leap_second;
  this->name_parser_ = &name;
}

EventsInputFiles_pskel::
EventsInputFiles_pskel ()
: Orbit_ephemeris_path_parser_ (0),
  Orbit_ephemeris_rootname_parser_ (0),
  Data_path_parser_ (0),
  Planet_ephemeris_parser_ (0),
  EOP_parameters_parser_ (0),
  PCK_data_parser_ (0),
  Leap_second_parser_ (0),
  name_parser_ (0)
{
}

// EventsOutputFiles_pskel
//

void EventsOutputFiles_pskel::
TG_contacts_parser (::xml_schema::string_pskel& p)
{
  this->TG_contacts_parser_ = &p;
}

void EventsOutputFiles_pskel::
GS_contacts_parser (::xml_schema::string_pskel& p)
{
  this->GS_contacts_parser_ = &p;
}

void EventsOutputFiles_pskel::
Eclipse_times_parser (::xml_schema::string_pskel& p)
{
  this->Eclipse_times_parser_ = &p;
}

void EventsOutputFiles_pskel::
name_parser (::xml_schema::string_pskel& p)
{
  this->name_parser_ = &p;
}

void EventsOutputFiles_pskel::
parsers (::xml_schema::string_pskel& TG_contacts,
         ::xml_schema::string_pskel& GS_contacts,
         ::xml_schema::string_pskel& Eclipse_times,
         ::xml_schema::string_pskel& name)
{
  this->TG_contacts_parser_ = &TG_contacts;
  this->GS_contacts_parser_ = &GS_contacts;
  this->Eclipse_times_parser_ = &Eclipse_times;
  this->name_parser_ = &name;
}

EventsOutputFiles_pskel::
EventsOutputFiles_pskel ()
: TG_contacts_parser_ (0),
  GS_contacts_parser_ (0),
  Eclipse_times_parser_ (0),
  name_parser_ (0)
{
}

// license_pskel
//

void license_pskel::
licenseName_parser (::xml_schema::string_pskel& p)
{
  this->licenseName_parser_ = &p;
}

void license_pskel::
licenseURL_parser (::xml_schema::uri_pskel& p)
{
  this->licenseURL_parser_ = &p;
}

void license_pskel::
parsers (::xml_schema::string_pskel& licenseName,
         ::xml_schema::uri_pskel& licenseURL)
{
  this->licenseName_parser_ = &licenseName;
  this->licenseURL_parser_ = &licenseURL;
}

license_pskel::
license_pskel ()
: licenseName_parser_ (0),
  licenseURL_parser_ (0)
{
}

// AreaType_pskel
//

void AreaType_pskel::
post_AreaType ()
{
}

// LengthType_pskel
//

void LengthType_pskel::
post_LengthType ()
{
}

// InertiaType_pskel
//

void InertiaType_pskel::
post_InertiaType ()
{
}

// MassType_pskel
//

void MassType_pskel::
post_MassType ()
{
}

// AngleType_pskel
//

void AngleType_pskel::
post_AngleType ()
{
}

// PositiveNumber_pskel
//

void PositiveNumber_pskel::
post_PositiveNumber ()
{
}

// posV_pskel
//

void posV_pskel::
x (double)
{
}

void posV_pskel::
y (double)
{
}

void posV_pskel::
z (double)
{
}

void posV_pskel::
name (const ::std::string&)
{
}

void posV_pskel::
unit (const ::std::string&)
{
}

void posV_pskel::
post_posV ()
{
}

bool posV_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "x" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->x_parser_;

    if (this->x_parser_)
      this->x_parser_->pre ();

    return true;
  }

  if (n == "y" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->y_parser_;

    if (this->y_parser_)
      this->y_parser_->pre ();

    return true;
  }

  if (n == "z" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->z_parser_;

    if (this->z_parser_)
      this->z_parser_->pre ();

    return true;
  }

  return false;
}

bool posV_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "x" && ns.empty ())
  {
    if (this->x_parser_)
      this->x (this->x_parser_->post_double ());

    return true;
  }

  if (n == "y" && ns.empty ())
  {
    if (this->y_parser_)
      this->y (this->y_parser_->post_double ());

    return true;
  }

  if (n == "z" && ns.empty ())
  {
    if (this->z_parser_)
      this->z (this->z_parser_->post_double ());

    return true;
  }

  return false;
}

bool posV_pskel::
_attribute_impl (const ::xml_schema::ro_string& ns,
                 const ::xml_schema::ro_string& n,
                 const ::xml_schema::ro_string& v)
{
  if (this->::xml_schema::complex_content::_attribute_impl (ns, n, v))
    return true;

  if (n == "name" && ns.empty ())
  {
    if (this->name_parser_)
    {
      this->name_parser_->pre ();
      this->name_parser_->_pre_impl ();
      this->name_parser_->_characters (v);
      this->name_parser_->_post_impl ();
      this->name (this->name_parser_->post_string ());
    }

    return true;
  }

  if (n == "unit" && ns.empty ())
  {
    if (this->unit_parser_)
    {
      this->unit_parser_->pre ();
      this->unit_parser_->_pre_impl ();
      this->unit_parser_->_characters (v);
      this->unit_parser_->_post_impl ();
      this->unit (this->unit_parser_->post_string ());
    }

    return true;
  }

  return false;
}

// velV_pskel
//

void velV_pskel::
vx (double)
{
}

void velV_pskel::
vy (double)
{
}

void velV_pskel::
vz (double)
{
}

void velV_pskel::
name (const ::std::string&)
{
}

void velV_pskel::
unit (const ::std::string&)
{
}

void velV_pskel::
post_velV ()
{
}

bool velV_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "vx" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->vx_parser_;

    if (this->vx_parser_)
      this->vx_parser_->pre ();

    return true;
  }

  if (n == "vy" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->vy_parser_;

    if (this->vy_parser_)
      this->vy_parser_->pre ();

    return true;
  }

  if (n == "vz" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->vz_parser_;

    if (this->vz_parser_)
      this->vz_parser_->pre ();

    return true;
  }

  return false;
}

bool velV_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "vx" && ns.empty ())
  {
    if (this->vx_parser_)
      this->vx (this->vx_parser_->post_double ());

    return true;
  }

  if (n == "vy" && ns.empty ())
  {
    if (this->vy_parser_)
      this->vy (this->vy_parser_->post_double ());

    return true;
  }

  if (n == "vz" && ns.empty ())
  {
    if (this->vz_parser_)
      this->vz (this->vz_parser_->post_double ());

    return true;
  }

  return false;
}

bool velV_pskel::
_attribute_impl (const ::xml_schema::ro_string& ns,
                 const ::xml_schema::ro_string& n,
                 const ::xml_schema::ro_string& v)
{
  if (this->::xml_schema::complex_content::_attribute_impl (ns, n, v))
    return true;

  if (n == "name" && ns.empty ())
  {
    if (this->name_parser_)
    {
      this->name_parser_->pre ();
      this->name_parser_->_pre_impl ();
      this->name_parser_->_characters (v);
      this->name_parser_->_post_impl ();
      this->name (this->name_parser_->post_string ());
    }

    return true;
  }

  if (n == "unit" && ns.empty ())
  {
    if (this->unit_parser_)
    {
      this->unit_parser_->pre ();
      this->unit_parser_->_pre_impl ();
      this->unit_parser_->_characters (v);
      this->unit_parser_->_post_impl ();
      this->unit (this->unit_parser_->post_string ());
    }

    return true;
  }

  return false;
}

// Vector_pskel
//

void Vector_pskel::
x (double)
{
}

void Vector_pskel::
y (double)
{
}

void Vector_pskel::
z (double)
{
}

void Vector_pskel::
name (const ::std::string&)
{
}

void Vector_pskel::
unit (const ::std::string&)
{
}

void Vector_pskel::
post_Vector ()
{
}

bool Vector_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "x" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->x_parser_;

    if (this->x_parser_)
      this->x_parser_->pre ();

    return true;
  }

  if (n == "y" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->y_parser_;

    if (this->y_parser_)
      this->y_parser_->pre ();

    return true;
  }

  if (n == "z" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->z_parser_;

    if (this->z_parser_)
      this->z_parser_->pre ();

    return true;
  }

  return false;
}

bool Vector_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "x" && ns.empty ())
  {
    if (this->x_parser_)
      this->x (this->x_parser_->post_double ());

    return true;
  }

  if (n == "y" && ns.empty ())
  {
    if (this->y_parser_)
      this->y (this->y_parser_->post_double ());

    return true;
  }

  if (n == "z" && ns.empty ())
  {
    if (this->z_parser_)
      this->z (this->z_parser_->post_double ());

    return true;
  }

  return false;
}

bool Vector_pskel::
_attribute_impl (const ::xml_schema::ro_string& ns,
                 const ::xml_schema::ro_string& n,
                 const ::xml_schema::ro_string& v)
{
  if (this->::xml_schema::complex_content::_attribute_impl (ns, n, v))
    return true;

  if (n == "name" && ns.empty ())
  {
    if (this->name_parser_)
    {
      this->name_parser_->pre ();
      this->name_parser_->_pre_impl ();
      this->name_parser_->_characters (v);
      this->name_parser_->_post_impl ();
      this->name (this->name_parser_->post_string ());
    }

    return true;
  }

  if (n == "unit" && ns.empty ())
  {
    if (this->unit_parser_)
    {
      this->unit_parser_->pre ();
      this->unit_parser_->_pre_impl ();
      this->unit_parser_->_characters (v);
      this->unit_parser_->_post_impl ();
      this->unit (this->unit_parser_->post_string ());
    }

    return true;
  }

  return false;
}

// RotationMatrix_3x3_pskel
//

void RotationMatrix_3x3_pskel::
m11 (double)
{
}

void RotationMatrix_3x3_pskel::
m12 (double)
{
}

void RotationMatrix_3x3_pskel::
m13 (double)
{
}

void RotationMatrix_3x3_pskel::
m21 (double)
{
}

void RotationMatrix_3x3_pskel::
m22 (double)
{
}

void RotationMatrix_3x3_pskel::
m23 (double)
{
}

void RotationMatrix_3x3_pskel::
m31 (double)
{
}

void RotationMatrix_3x3_pskel::
m32 (double)
{
}

void RotationMatrix_3x3_pskel::
m33 (double)
{
}

void RotationMatrix_3x3_pskel::
name (const ::std::string&)
{
}

void RotationMatrix_3x3_pskel::
post_RotationMatrix_3x3 ()
{
}

bool RotationMatrix_3x3_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "m11" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->m11_parser_;

    if (this->m11_parser_)
      this->m11_parser_->pre ();

    return true;
  }

  if (n == "m12" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->m12_parser_;

    if (this->m12_parser_)
      this->m12_parser_->pre ();

    return true;
  }

  if (n == "m13" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->m13_parser_;

    if (this->m13_parser_)
      this->m13_parser_->pre ();

    return true;
  }

  if (n == "m21" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->m21_parser_;

    if (this->m21_parser_)
      this->m21_parser_->pre ();

    return true;
  }

  if (n == "m22" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->m22_parser_;

    if (this->m22_parser_)
      this->m22_parser_->pre ();

    return true;
  }

  if (n == "m23" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->m23_parser_;

    if (this->m23_parser_)
      this->m23_parser_->pre ();

    return true;
  }

  if (n == "m31" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->m31_parser_;

    if (this->m31_parser_)
      this->m31_parser_->pre ();

    return true;
  }

  if (n == "m32" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->m32_parser_;

    if (this->m32_parser_)
      this->m32_parser_->pre ();

    return true;
  }

  if (n == "m33" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->m33_parser_;

    if (this->m33_parser_)
      this->m33_parser_->pre ();

    return true;
  }

  return false;
}

bool RotationMatrix_3x3_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "m11" && ns.empty ())
  {
    if (this->m11_parser_)
      this->m11 (this->m11_parser_->post_double ());

    return true;
  }

  if (n == "m12" && ns.empty ())
  {
    if (this->m12_parser_)
      this->m12 (this->m12_parser_->post_double ());

    return true;
  }

  if (n == "m13" && ns.empty ())
  {
    if (this->m13_parser_)
      this->m13 (this->m13_parser_->post_double ());

    return true;
  }

  if (n == "m21" && ns.empty ())
  {
    if (this->m21_parser_)
      this->m21 (this->m21_parser_->post_double ());

    return true;
  }

  if (n == "m22" && ns.empty ())
  {
    if (this->m22_parser_)
      this->m22 (this->m22_parser_->post_double ());

    return true;
  }

  if (n == "m23" && ns.empty ())
  {
    if (this->m23_parser_)
      this->m23 (this->m23_parser_->post_double ());

    return true;
  }

  if (n == "m31" && ns.empty ())
  {
    if (this->m31_parser_)
      this->m31 (this->m31_parser_->post_double ());

    return true;
  }

  if (n == "m32" && ns.empty ())
  {
    if (this->m32_parser_)
      this->m32 (this->m32_parser_->post_double ());

    return true;
  }

  if (n == "m33" && ns.empty ())
  {
    if (this->m33_parser_)
      this->m33 (this->m33_parser_->post_double ());

    return true;
  }

  return false;
}

bool RotationMatrix_3x3_pskel::
_attribute_impl (const ::xml_schema::ro_string& ns,
                 const ::xml_schema::ro_string& n,
                 const ::xml_schema::ro_string& v)
{
  if (this->::xml_schema::complex_content::_attribute_impl (ns, n, v))
    return true;

  if (n == "name" && ns.empty ())
  {
    if (this->name_parser_)
    {
      this->name_parser_->pre ();
      this->name_parser_->_pre_impl ();
      this->name_parser_->_characters (v);
      this->name_parser_->_post_impl ();
      this->name (this->name_parser_->post_string ());
    }

    return true;
  }

  return false;
}

// Dimensioned_pskel
//

void Dimensioned_pskel::
unit (const ::std::string&)
{
}

void Dimensioned_pskel::
post_Dimensioned ()
{
  post_PositiveNumber ();
}

bool Dimensioned_pskel::
_attribute_impl (const ::xml_schema::ro_string& ns,
                 const ::xml_schema::ro_string& n,
                 const ::xml_schema::ro_string& v)
{
  if (this->::PositiveNumber_pskel::_attribute_impl (ns, n, v))
    return true;

  if (n == "unit" && ns.empty ())
  {
    if (this->unit_parser_)
    {
      this->unit_parser_->pre ();
      this->unit_parser_->_pre_impl ();
      this->unit_parser_->_characters (v);
      this->unit_parser_->_post_impl ();
      this->unit (this->unit_parser_->post_string ());
    }

    return true;
  }

  return false;
}

// Angle_pskel
//

void Angle_pskel::
unit ()
{
}

void Angle_pskel::
post_Angle ()
{
}

bool Angle_pskel::
_attribute_impl (const ::xml_schema::ro_string& ns,
                 const ::xml_schema::ro_string& n,
                 const ::xml_schema::ro_string& v)
{
  if (this->::xml_schema::double_pskel::_attribute_impl (ns, n, v))
    return true;

  if (n == "unit" && ns.empty ())
  {
    if (this->unit_parser_)
    {
      this->unit_parser_->pre ();
      this->unit_parser_->_pre_impl ();
      this->unit_parser_->_characters (v);
      this->unit_parser_->_post_impl ();
      this->unit_parser_->post_AngleType ();
      this->unit ();
    }

    return true;
  }

  return false;
}

// Altitude_pskel
//

void Altitude_pskel::
unit ()
{
}

void Altitude_pskel::
post_Altitude ()
{
}

bool Altitude_pskel::
_attribute_impl (const ::xml_schema::ro_string& ns,
                 const ::xml_schema::ro_string& n,
                 const ::xml_schema::ro_string& v)
{
  if (this->::xml_schema::double_pskel::_attribute_impl (ns, n, v))
    return true;

  if (n == "unit" && ns.empty ())
  {
    if (this->unit_parser_)
    {
      this->unit_parser_->pre ();
      this->unit_parser_->_pre_impl ();
      this->unit_parser_->_characters (v);
      this->unit_parser_->_post_impl ();
      this->unit_parser_->post_LengthType ();
      this->unit ();
    }

    return true;
  }

  return false;
}

// MoI_pskel
//

void MoI_pskel::
unit ()
{
}

void MoI_pskel::
post_MoI ()
{
  post_PositiveNumber ();
}

bool MoI_pskel::
_attribute_impl (const ::xml_schema::ro_string& ns,
                 const ::xml_schema::ro_string& n,
                 const ::xml_schema::ro_string& v)
{
  if (this->::PositiveNumber_pskel::_attribute_impl (ns, n, v))
    return true;

  if (n == "unit" && ns.empty ())
  {
    if (this->unit_parser_)
    {
      this->unit_parser_->pre ();
      this->unit_parser_->_pre_impl ();
      this->unit_parser_->_characters (v);
      this->unit_parser_->_post_impl ();
      this->unit_parser_->post_InertiaType ();
      this->unit ();
    }

    return true;
  }

  return false;
}

// Mass_pskel
//

void Mass_pskel::
unit ()
{
}

void Mass_pskel::
post_Mass ()
{
  post_PositiveNumber ();
}

bool Mass_pskel::
_attribute_impl (const ::xml_schema::ro_string& ns,
                 const ::xml_schema::ro_string& n,
                 const ::xml_schema::ro_string& v)
{
  if (this->::PositiveNumber_pskel::_attribute_impl (ns, n, v))
    return true;

  if (n == "unit" && ns.empty ())
  {
    if (this->unit_parser_)
    {
      this->unit_parser_->pre ();
      this->unit_parser_->_pre_impl ();
      this->unit_parser_->_characters (v);
      this->unit_parser_->_post_impl ();
      this->unit_parser_->post_MassType ();
      this->unit ();
    }

    return true;
  }

  return false;
}

// simparam_pskel
//

void simparam_pskel::
fileheader ()
{
}

void simparam_pskel::
SC_Faces ()
{
}

void simparam_pskel::
SC_properties ()
{
}

void simparam_pskel::
InputFiles ()
{
}

void simparam_pskel::
OutputFiles ()
{
}

void simparam_pskel::
SimParameters ()
{
}

void simparam_pskel::
SensorsActuators ()
{
}

void simparam_pskel::
Maneuvers ()
{
}

void simparam_pskel::
name (const ::std::string&)
{
}

void simparam_pskel::
post_simparam ()
{
}

bool simparam_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "fileheader" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->fileheader_parser_;

    if (this->fileheader_parser_)
      this->fileheader_parser_->pre ();

    return true;
  }

  if (n == "SC_Faces" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->SC_Faces_parser_;

    if (this->SC_Faces_parser_)
      this->SC_Faces_parser_->pre ();

    return true;
  }

  if (n == "SC_properties" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->SC_properties_parser_;

    if (this->SC_properties_parser_)
      this->SC_properties_parser_->pre ();

    return true;
  }

  if (n == "InputFiles" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->InputFiles_parser_;

    if (this->InputFiles_parser_)
      this->InputFiles_parser_->pre ();

    return true;
  }

  if (n == "OutputFiles" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->OutputFiles_parser_;

    if (this->OutputFiles_parser_)
      this->OutputFiles_parser_->pre ();

    return true;
  }

  if (n == "SimParameters" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->SimParameters_parser_;

    if (this->SimParameters_parser_)
      this->SimParameters_parser_->pre ();

    return true;
  }

  if (n == "SensorsActuators" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->SensorsActuators_parser_;

    if (this->SensorsActuators_parser_)
      this->SensorsActuators_parser_->pre ();

    return true;
  }

  if (n == "Maneuvers" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->Maneuvers_parser_;

    if (this->Maneuvers_parser_)
      this->Maneuvers_parser_->pre ();

    return true;
  }

  return false;
}

bool simparam_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "fileheader" && ns.empty ())
  {
    if (this->fileheader_parser_)
    {
      this->fileheader_parser_->post_fileheader ();
      this->fileheader ();
    }

    return true;
  }

  if (n == "SC_Faces" && ns.empty ())
  {
    if (this->SC_Faces_parser_)
    {
      this->SC_Faces_parser_->post_SC_Faces ();
      this->SC_Faces ();
    }

    return true;
  }

  if (n == "SC_properties" && ns.empty ())
  {
    if (this->SC_properties_parser_)
    {
      this->SC_properties_parser_->post_SC_properties ();
      this->SC_properties ();
    }

    return true;
  }

  if (n == "InputFiles" && ns.empty ())
  {
    if (this->InputFiles_parser_)
    {
      this->InputFiles_parser_->post_InputFiles ();
      this->InputFiles ();
    }

    return true;
  }

  if (n == "OutputFiles" && ns.empty ())
  {
    if (this->OutputFiles_parser_)
    {
      this->OutputFiles_parser_->post_OutputFiles ();
      this->OutputFiles ();
    }

    return true;
  }

  if (n == "SimParameters" && ns.empty ())
  {
    if (this->SimParameters_parser_)
    {
      this->SimParameters_parser_->post_SimParameters ();
      this->SimParameters ();
    }

    return true;
  }

  if (n == "SensorsActuators" && ns.empty ())
  {
    if (this->SensorsActuators_parser_)
    {
      this->SensorsActuators_parser_->post_SensorsActuators ();
      this->SensorsActuators ();
    }

    return true;
  }

  if (n == "Maneuvers" && ns.empty ())
  {
    if (this->Maneuvers_parser_)
    {
      this->Maneuvers_parser_->post_Maneuvers ();
      this->Maneuvers ();
    }

    return true;
  }

  return false;
}

bool simparam_pskel::
_attribute_impl (const ::xml_schema::ro_string& ns,
                 const ::xml_schema::ro_string& n,
                 const ::xml_schema::ro_string& v)
{
  if (this->::xml_schema::complex_content::_attribute_impl (ns, n, v))
    return true;

  if (n == "name" && ns.empty ())
  {
    if (this->name_parser_)
    {
      this->name_parser_->pre ();
      this->name_parser_->_pre_impl ();
      this->name_parser_->_characters (v);
      this->name_parser_->_post_impl ();
      this->name (this->name_parser_->post_string ());
    }

    return true;
  }

  return false;
}

// eventsparam_pskel
//

void eventsparam_pskel::
fileheader ()
{
}

void eventsparam_pskel::
CompParameters ()
{
}

void eventsparam_pskel::
TGs ()
{
}

void eventsparam_pskel::
GSs ()
{
}

void eventsparam_pskel::
EventsInputFiles ()
{
}

void eventsparam_pskel::
EventsOutputFiles ()
{
}

void eventsparam_pskel::
name (const ::std::string&)
{
}

void eventsparam_pskel::
post_eventsparam ()
{
}

bool eventsparam_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "fileheader" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->fileheader_parser_;

    if (this->fileheader_parser_)
      this->fileheader_parser_->pre ();

    return true;
  }

  if (n == "CompParameters" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->CompParameters_parser_;

    if (this->CompParameters_parser_)
      this->CompParameters_parser_->pre ();

    return true;
  }

  if (n == "TGs" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->TGs_parser_;

    if (this->TGs_parser_)
      this->TGs_parser_->pre ();

    return true;
  }

  if (n == "GSs" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->GSs_parser_;

    if (this->GSs_parser_)
      this->GSs_parser_->pre ();

    return true;
  }

  if (n == "EventsInputFiles" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->EventsInputFiles_parser_;

    if (this->EventsInputFiles_parser_)
      this->EventsInputFiles_parser_->pre ();

    return true;
  }

  if (n == "EventsOutputFiles" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->EventsOutputFiles_parser_;

    if (this->EventsOutputFiles_parser_)
      this->EventsOutputFiles_parser_->pre ();

    return true;
  }

  return false;
}

bool eventsparam_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "fileheader" && ns.empty ())
  {
    if (this->fileheader_parser_)
    {
      this->fileheader_parser_->post_fileheader ();
      this->fileheader ();
    }

    return true;
  }

  if (n == "CompParameters" && ns.empty ())
  {
    if (this->CompParameters_parser_)
    {
      this->CompParameters_parser_->post_CompParameters ();
      this->CompParameters ();
    }

    return true;
  }

  if (n == "TGs" && ns.empty ())
  {
    if (this->TGs_parser_)
    {
      this->TGs_parser_->post_TGs ();
      this->TGs ();
    }

    return true;
  }

  if (n == "GSs" && ns.empty ())
  {
    if (this->GSs_parser_)
    {
      this->GSs_parser_->post_GSs ();
      this->GSs ();
    }

    return true;
  }

  if (n == "EventsInputFiles" && ns.empty ())
  {
    if (this->EventsInputFiles_parser_)
    {
      this->EventsInputFiles_parser_->post_EventsInputFiles ();
      this->EventsInputFiles ();
    }

    return true;
  }

  if (n == "EventsOutputFiles" && ns.empty ())
  {
    if (this->EventsOutputFiles_parser_)
    {
      this->EventsOutputFiles_parser_->post_EventsOutputFiles ();
      this->EventsOutputFiles ();
    }

    return true;
  }

  return false;
}

bool eventsparam_pskel::
_attribute_impl (const ::xml_schema::ro_string& ns,
                 const ::xml_schema::ro_string& n,
                 const ::xml_schema::ro_string& v)
{
  if (this->::xml_schema::complex_content::_attribute_impl (ns, n, v))
    return true;

  if (n == "name" && ns.empty ())
  {
    if (this->name_parser_)
    {
      this->name_parser_->pre ();
      this->name_parser_->_pre_impl ();
      this->name_parser_->_characters (v);
      this->name_parser_->_post_impl ();
      this->name (this->name_parser_->post_string ());
    }

    return true;
  }

  return false;
}

// fileheader_pskel
//

void fileheader_pskel::
author (const ::std::string&)
{
}

void fileheader_pskel::
email (const ::std::string&)
{
}

void fileheader_pskel::
organization (const ::std::string&)
{
}

void fileheader_pskel::
license ()
{
}

void fileheader_pskel::
sensitivity (const ::std::string&)
{
}

void fileheader_pskel::
filecreationdate (const ::xml_schema::date&)
{
}

void fileheader_pskel::
version (const ::std::string&)
{
}

void fileheader_pskel::
description (const ::std::string&)
{
}

void fileheader_pskel::
note (const ::std::string&)
{
}

void fileheader_pskel::
limitation (const ::std::string&)
{
}

void fileheader_pskel::
reference ()
{
}

void fileheader_pskel::
post_fileheader ()
{
}

bool fileheader_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "author" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->author_parser_;

    if (this->author_parser_)
      this->author_parser_->pre ();

    return true;
  }

  if (n == "email" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->email_parser_;

    if (this->email_parser_)
      this->email_parser_->pre ();

    return true;
  }

  if (n == "organization" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->organization_parser_;

    if (this->organization_parser_)
      this->organization_parser_->pre ();

    return true;
  }

  if (n == "license" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->license_parser_;

    if (this->license_parser_)
      this->license_parser_->pre ();

    return true;
  }

  if (n == "sensitivity" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->sensitivity_parser_;

    if (this->sensitivity_parser_)
      this->sensitivity_parser_->pre ();

    return true;
  }

  if (n == "filecreationdate" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->filecreationdate_parser_;

    if (this->filecreationdate_parser_)
      this->filecreationdate_parser_->pre ();

    return true;
  }

  if (n == "version" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->version_parser_;

    if (this->version_parser_)
      this->version_parser_->pre ();

    return true;
  }

  if (n == "description" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->description_parser_;

    if (this->description_parser_)
      this->description_parser_->pre ();

    return true;
  }

  if (n == "note" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->note_parser_;

    if (this->note_parser_)
      this->note_parser_->pre ();

    return true;
  }

  if (n == "limitation" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->limitation_parser_;

    if (this->limitation_parser_)
      this->limitation_parser_->pre ();

    return true;
  }

  if (n == "reference" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->reference_parser_;

    if (this->reference_parser_)
      this->reference_parser_->pre ();

    return true;
  }

  return false;
}

bool fileheader_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "author" && ns.empty ())
  {
    if (this->author_parser_)
      this->author (this->author_parser_->post_string ());

    return true;
  }

  if (n == "email" && ns.empty ())
  {
    if (this->email_parser_)
      this->email (this->email_parser_->post_string ());

    return true;
  }

  if (n == "organization" && ns.empty ())
  {
    if (this->organization_parser_)
      this->organization (this->organization_parser_->post_string ());

    return true;
  }

  if (n == "license" && ns.empty ())
  {
    if (this->license_parser_)
    {
      this->license_parser_->post_license ();
      this->license ();
    }

    return true;
  }

  if (n == "sensitivity" && ns.empty ())
  {
    if (this->sensitivity_parser_)
      this->sensitivity (this->sensitivity_parser_->post_string ());

    return true;
  }

  if (n == "filecreationdate" && ns.empty ())
  {
    if (this->filecreationdate_parser_)
      this->filecreationdate (this->filecreationdate_parser_->post_date ());

    return true;
  }

  if (n == "version" && ns.empty ())
  {
    if (this->version_parser_)
      this->version (this->version_parser_->post_string ());

    return true;
  }

  if (n == "description" && ns.empty ())
  {
    if (this->description_parser_)
      this->description (this->description_parser_->post_string ());

    return true;
  }

  if (n == "note" && ns.empty ())
  {
    if (this->note_parser_)
      this->note (this->note_parser_->post_string ());

    return true;
  }

  if (n == "limitation" && ns.empty ())
  {
    if (this->limitation_parser_)
      this->limitation (this->limitation_parser_->post_string ());

    return true;
  }

  if (n == "reference" && ns.empty ())
  {
    if (this->reference_parser_)
    {
      this->reference_parser_->post_reference ();
      this->reference ();
    }

    return true;
  }

  return false;
}

// reference_pskel
//

void reference_pskel::
author (const ::std::string&)
{
}

void reference_pskel::
date (const ::std::string&)
{
}

void reference_pskel::
refID (const ::std::string&)
{
}

void reference_pskel::
title (const ::std::string&)
{
}

void reference_pskel::
post_reference ()
{
}

bool reference_pskel::
_attribute_impl (const ::xml_schema::ro_string& ns,
                 const ::xml_schema::ro_string& n,
                 const ::xml_schema::ro_string& v)
{
  if (this->::xml_schema::complex_content::_attribute_impl (ns, n, v))
    return true;

  if (n == "author" && ns.empty ())
  {
    if (this->author_parser_)
    {
      this->author_parser_->pre ();
      this->author_parser_->_pre_impl ();
      this->author_parser_->_characters (v);
      this->author_parser_->_post_impl ();
      this->author (this->author_parser_->post_string ());
    }

    return true;
  }

  if (n == "date" && ns.empty ())
  {
    if (this->date_parser_)
    {
      this->date_parser_->pre ();
      this->date_parser_->_pre_impl ();
      this->date_parser_->_characters (v);
      this->date_parser_->_post_impl ();
      this->date (this->date_parser_->post_string ());
    }

    return true;
  }

  if (n == "refID" && ns.empty ())
  {
    if (this->refID_parser_)
    {
      this->refID_parser_->pre ();
      this->refID_parser_->_pre_impl ();
      this->refID_parser_->_characters (v);
      this->refID_parser_->_post_impl ();
      this->refID (this->refID_parser_->post_string ());
    }

    return true;
  }

  if (n == "title" && ns.empty ())
  {
    if (this->title_parser_)
    {
      this->title_parser_->pre ();
      this->title_parser_->_pre_impl ();
      this->title_parser_->_characters (v);
      this->title_parser_->_post_impl ();
      this->title (this->title_parser_->post_string ());
    }

    return true;
  }

  return false;
}

// Versor_pskel
//

void Versor_pskel::
x (double)
{
}

void Versor_pskel::
y (double)
{
}

void Versor_pskel::
z (double)
{
}

void Versor_pskel::
name (const ::std::string&)
{
}

void Versor_pskel::
post_Versor ()
{
}

bool Versor_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "x" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->x_parser_;

    if (this->x_parser_)
      this->x_parser_->pre ();

    return true;
  }

  if (n == "y" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->y_parser_;

    if (this->y_parser_)
      this->y_parser_->pre ();

    return true;
  }

  if (n == "z" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->z_parser_;

    if (this->z_parser_)
      this->z_parser_->pre ();

    return true;
  }

  return false;
}

bool Versor_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "x" && ns.empty ())
  {
    if (this->x_parser_)
      this->x (this->x_parser_->post_double ());

    return true;
  }

  if (n == "y" && ns.empty ())
  {
    if (this->y_parser_)
      this->y (this->y_parser_->post_double ());

    return true;
  }

  if (n == "z" && ns.empty ())
  {
    if (this->z_parser_)
      this->z (this->z_parser_->post_double ());

    return true;
  }

  return false;
}

bool Versor_pskel::
_attribute_impl (const ::xml_schema::ro_string& ns,
                 const ::xml_schema::ro_string& n,
                 const ::xml_schema::ro_string& v)
{
  if (this->::xml_schema::complex_content::_attribute_impl (ns, n, v))
    return true;

  if (n == "name" && ns.empty ())
  {
    if (this->name_parser_)
    {
      this->name_parser_->pre ();
      this->name_parser_->_pre_impl ();
      this->name_parser_->_characters (v);
      this->name_parser_->_post_impl ();
      this->name (this->name_parser_->post_string ());
    }

    return true;
  }

  return false;
}

// nMAX_pskel
//

void nMAX_pskel::
post_nMAX ()
{
}

// SC_Faces_pskel
//

void SC_Faces_pskel::
Face ()
{
}

void SC_Faces_pskel::
post_SC_Faces ()
{
}

bool SC_Faces_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "Face" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->Face_parser_;

    if (this->Face_parser_)
      this->Face_parser_->pre ();

    return true;
  }

  return false;
}

bool SC_Faces_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "Face" && ns.empty ())
  {
    if (this->Face_parser_)
    {
      this->Face_parser_->post_Face ();
      this->Face ();
    }

    return true;
  }

  return false;
}

// Face_pskel
//

void Face_pskel::
Area ()
{
}

void Face_pskel::
Versor ()
{
}

void Face_pskel::
Material (const ::std::string&)
{
}

void Face_pskel::
cP_position ()
{
}

void Face_pskel::
cA_position ()
{
}

void Face_pskel::
name (const ::std::string&)
{
}

void Face_pskel::
post_Face ()
{
}

bool Face_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "Area" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->Area_parser_;

    if (this->Area_parser_)
      this->Area_parser_->pre ();

    return true;
  }

  if (n == "Versor" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->Versor_parser_;

    if (this->Versor_parser_)
      this->Versor_parser_->pre ();

    return true;
  }

  if (n == "Material" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->Material_parser_;

    if (this->Material_parser_)
      this->Material_parser_->pre ();

    return true;
  }

  if (n == "cP_position" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->cP_position_parser_;

    if (this->cP_position_parser_)
      this->cP_position_parser_->pre ();

    return true;
  }

  if (n == "cA_position" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->cA_position_parser_;

    if (this->cA_position_parser_)
      this->cA_position_parser_->pre ();

    return true;
  }

  return false;
}

bool Face_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "Area" && ns.empty ())
  {
    if (this->Area_parser_)
    {
      this->Area_parser_->post_Area ();
      this->Area ();
    }

    return true;
  }

  if (n == "Versor" && ns.empty ())
  {
    if (this->Versor_parser_)
    {
      this->Versor_parser_->post_Versor ();
      this->Versor ();
    }

    return true;
  }

  if (n == "Material" && ns.empty ())
  {
    if (this->Material_parser_)
      this->Material (this->Material_parser_->post_string ());

    return true;
  }

  if (n == "cP_position" && ns.empty ())
  {
    if (this->cP_position_parser_)
    {
      this->cP_position_parser_->post_posV ();
      this->cP_position ();
    }

    return true;
  }

  if (n == "cA_position" && ns.empty ())
  {
    if (this->cA_position_parser_)
    {
      this->cA_position_parser_->post_posV ();
      this->cA_position ();
    }

    return true;
  }

  return false;
}

bool Face_pskel::
_attribute_impl (const ::xml_schema::ro_string& ns,
                 const ::xml_schema::ro_string& n,
                 const ::xml_schema::ro_string& v)
{
  if (this->::xml_schema::complex_content::_attribute_impl (ns, n, v))
    return true;

  if (n == "name" && ns.empty ())
  {
    if (this->name_parser_)
    {
      this->name_parser_->pre ();
      this->name_parser_->_pre_impl ();
      this->name_parser_->_characters (v);
      this->name_parser_->_post_impl ();
      this->name (this->name_parser_->post_string ());
    }

    return true;
  }

  return false;
}

// Length_pskel
//

void Length_pskel::
unit ()
{
}

void Length_pskel::
post_Length ()
{
  post_PositiveNumber ();
}

bool Length_pskel::
_attribute_impl (const ::xml_schema::ro_string& ns,
                 const ::xml_schema::ro_string& n,
                 const ::xml_schema::ro_string& v)
{
  if (this->::PositiveNumber_pskel::_attribute_impl (ns, n, v))
    return true;

  if (n == "unit" && ns.empty ())
  {
    if (this->unit_parser_)
    {
      this->unit_parser_->pre ();
      this->unit_parser_->_pre_impl ();
      this->unit_parser_->_characters (v);
      this->unit_parser_->_post_impl ();
      this->unit_parser_->post_LengthType ();
      this->unit ();
    }

    return true;
  }

  return false;
}

// Area_pskel
//

void Area_pskel::
unit ()
{
}

void Area_pskel::
post_Area ()
{
  post_PositiveNumber ();
}

bool Area_pskel::
_attribute_impl (const ::xml_schema::ro_string& ns,
                 const ::xml_schema::ro_string& n,
                 const ::xml_schema::ro_string& v)
{
  if (this->::PositiveNumber_pskel::_attribute_impl (ns, n, v))
    return true;

  if (n == "unit" && ns.empty ())
  {
    if (this->unit_parser_)
    {
      this->unit_parser_->pre ();
      this->unit_parser_->_pre_impl ();
      this->unit_parser_->_characters (v);
      this->unit_parser_->_post_impl ();
      this->unit_parser_->post_AreaType ();
      this->unit ();
    }

    return true;
  }

  return false;
}

// SC_properties_pskel
//

void SC_properties_pskel::
InertiaMatrix ()
{
}

void SC_properties_pskel::
CoG ()
{
}

void SC_properties_pskel::
Coefficients ()
{
}

void SC_properties_pskel::
Areas ()
{
}

void SC_properties_pskel::
SC_dipole ()
{
}

void SC_properties_pskel::
post_SC_properties ()
{
}

bool SC_properties_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "InertiaMatrix" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->InertiaMatrix_parser_;

    if (this->InertiaMatrix_parser_)
      this->InertiaMatrix_parser_->pre ();

    return true;
  }

  if (n == "CoG" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->CoG_parser_;

    if (this->CoG_parser_)
      this->CoG_parser_->pre ();

    return true;
  }

  if (n == "Coefficients" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->Coefficients_parser_;

    if (this->Coefficients_parser_)
      this->Coefficients_parser_->pre ();

    return true;
  }

  if (n == "Areas" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->Areas_parser_;

    if (this->Areas_parser_)
      this->Areas_parser_->pre ();

    return true;
  }

  if (n == "SC_dipole" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->SC_dipole_parser_;

    if (this->SC_dipole_parser_)
      this->SC_dipole_parser_->pre ();

    return true;
  }

  return false;
}

bool SC_properties_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "InertiaMatrix" && ns.empty ())
  {
    if (this->InertiaMatrix_parser_)
    {
      this->InertiaMatrix_parser_->post_InertiaMatrix ();
      this->InertiaMatrix ();
    }

    return true;
  }

  if (n == "CoG" && ns.empty ())
  {
    if (this->CoG_parser_)
    {
      this->CoG_parser_->post_CoG ();
      this->CoG ();
    }

    return true;
  }

  if (n == "Coefficients" && ns.empty ())
  {
    if (this->Coefficients_parser_)
    {
      this->Coefficients_parser_->post_Coefficients ();
      this->Coefficients ();
    }

    return true;
  }

  if (n == "Areas" && ns.empty ())
  {
    if (this->Areas_parser_)
    {
      this->Areas_parser_->post_Areas ();
      this->Areas ();
    }

    return true;
  }

  if (n == "SC_dipole" && ns.empty ())
  {
    if (this->SC_dipole_parser_)
    {
      this->SC_dipole_parser_->post_posV ();
      this->SC_dipole ();
    }

    return true;
  }

  return false;
}

// InertiaMatrix_pskel
//

void InertiaMatrix_pskel::
Ixx ()
{
}

void InertiaMatrix_pskel::
Iyy ()
{
}

void InertiaMatrix_pskel::
Izz ()
{
}

void InertiaMatrix_pskel::
Ixy (double)
{
}

void InertiaMatrix_pskel::
Ixz (double)
{
}

void InertiaMatrix_pskel::
Iyz (double)
{
}

void InertiaMatrix_pskel::
unit ()
{
}

void InertiaMatrix_pskel::
post_InertiaMatrix ()
{
}

bool InertiaMatrix_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "Ixx" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->Ixx_parser_;

    if (this->Ixx_parser_)
      this->Ixx_parser_->pre ();

    return true;
  }

  if (n == "Iyy" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->Iyy_parser_;

    if (this->Iyy_parser_)
      this->Iyy_parser_->pre ();

    return true;
  }

  if (n == "Izz" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->Izz_parser_;

    if (this->Izz_parser_)
      this->Izz_parser_->pre ();

    return true;
  }

  if (n == "Ixy" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->Ixy_parser_;

    if (this->Ixy_parser_)
      this->Ixy_parser_->pre ();

    return true;
  }

  if (n == "Ixz" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->Ixz_parser_;

    if (this->Ixz_parser_)
      this->Ixz_parser_->pre ();

    return true;
  }

  if (n == "Iyz" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->Iyz_parser_;

    if (this->Iyz_parser_)
      this->Iyz_parser_->pre ();

    return true;
  }

  return false;
}

bool InertiaMatrix_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "Ixx" && ns.empty ())
  {
    if (this->Ixx_parser_)
    {
      this->Ixx_parser_->post_MoI ();
      this->Ixx ();
    }

    return true;
  }

  if (n == "Iyy" && ns.empty ())
  {
    if (this->Iyy_parser_)
    {
      this->Iyy_parser_->post_MoI ();
      this->Iyy ();
    }

    return true;
  }

  if (n == "Izz" && ns.empty ())
  {
    if (this->Izz_parser_)
    {
      this->Izz_parser_->post_MoI ();
      this->Izz ();
    }

    return true;
  }

  if (n == "Ixy" && ns.empty ())
  {
    if (this->Ixy_parser_)
      this->Ixy (this->Ixy_parser_->post_double ());

    return true;
  }

  if (n == "Ixz" && ns.empty ())
  {
    if (this->Ixz_parser_)
      this->Ixz (this->Ixz_parser_->post_double ());

    return true;
  }

  if (n == "Iyz" && ns.empty ())
  {
    if (this->Iyz_parser_)
      this->Iyz (this->Iyz_parser_->post_double ());

    return true;
  }

  return false;
}

bool InertiaMatrix_pskel::
_attribute_impl (const ::xml_schema::ro_string& ns,
                 const ::xml_schema::ro_string& n,
                 const ::xml_schema::ro_string& v)
{
  if (this->::xml_schema::complex_content::_attribute_impl (ns, n, v))
    return true;

  if (n == "unit" && ns.empty ())
  {
    if (this->unit_parser_)
    {
      this->unit_parser_->pre ();
      this->unit_parser_->_pre_impl ();
      this->unit_parser_->_characters (v);
      this->unit_parser_->_post_impl ();
      this->unit_parser_->post_InertiaType ();
      this->unit ();
    }

    return true;
  }

  return false;
}

// CoG_pskel
//

void CoG_pskel::
SC_mass ()
{
}

void CoG_pskel::
CoG_pos ()
{
}

void CoG_pskel::
post_CoG ()
{
}

bool CoG_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "SC_mass" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->SC_mass_parser_;

    if (this->SC_mass_parser_)
      this->SC_mass_parser_->pre ();

    return true;
  }

  if (n == "CoG_pos" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->CoG_pos_parser_;

    if (this->CoG_pos_parser_)
      this->CoG_pos_parser_->pre ();

    return true;
  }

  return false;
}

bool CoG_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "SC_mass" && ns.empty ())
  {
    if (this->SC_mass_parser_)
    {
      this->SC_mass_parser_->post_Mass ();
      this->SC_mass ();
    }

    return true;
  }

  if (n == "CoG_pos" && ns.empty ())
  {
    if (this->CoG_pos_parser_)
    {
      this->CoG_pos_parser_->post_posV ();
      this->CoG_pos ();
    }

    return true;
  }

  return false;
}

// Coefficients_pskel
//

void Coefficients_pskel::
Cd ()
{
}

void Coefficients_pskel::
Cr ()
{
}

void Coefficients_pskel::
post_Coefficients ()
{
}

bool Coefficients_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "Cd" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->Cd_parser_;

    if (this->Cd_parser_)
      this->Cd_parser_->pre ();

    return true;
  }

  if (n == "Cr" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->Cr_parser_;

    if (this->Cr_parser_)
      this->Cr_parser_->pre ();

    return true;
  }

  return false;
}

bool Coefficients_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "Cd" && ns.empty ())
  {
    if (this->Cd_parser_)
    {
      this->Cd_parser_->post_PositiveNumber ();
      this->Cd ();
    }

    return true;
  }

  if (n == "Cr" && ns.empty ())
  {
    if (this->Cr_parser_)
    {
      this->Cr_parser_->post_PositiveNumber ();
      this->Cr ();
    }

    return true;
  }

  return false;
}

// Areas_pskel
//

void Areas_pskel::
Area_D ()
{
}

void Areas_pskel::
Area_R ()
{
}

void Areas_pskel::
post_Areas ()
{
}

bool Areas_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "Area_D" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->Area_D_parser_;

    if (this->Area_D_parser_)
      this->Area_D_parser_->pre ();

    return true;
  }

  if (n == "Area_R" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->Area_R_parser_;

    if (this->Area_R_parser_)
      this->Area_R_parser_->pre ();

    return true;
  }

  return false;
}

bool Areas_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "Area_D" && ns.empty ())
  {
    if (this->Area_D_parser_)
    {
      this->Area_D_parser_->post_PositiveNumber ();
      this->Area_D ();
    }

    return true;
  }

  if (n == "Area_R" && ns.empty ())
  {
    if (this->Area_R_parser_)
    {
      this->Area_R_parser_->post_PositiveNumber ();
      this->Area_R ();
    }

    return true;
  }

  return false;
}

// SimParameters_pskel
//

void SimParameters_pskel::
durstep ()
{
}

void SimParameters_pskel::
ORB_initstate ()
{
}

void SimParameters_pskel::
ATT_initstate ()
{
}

void SimParameters_pskel::
simoptions ()
{
}

void SimParameters_pskel::
post_SimParameters ()
{
}

bool SimParameters_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "durstep" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->durstep_parser_;

    if (this->durstep_parser_)
      this->durstep_parser_->pre ();

    return true;
  }

  if (n == "ORB_initstate" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->ORB_initstate_parser_;

    if (this->ORB_initstate_parser_)
      this->ORB_initstate_parser_->pre ();

    return true;
  }

  if (n == "ATT_initstate" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->ATT_initstate_parser_;

    if (this->ATT_initstate_parser_)
      this->ATT_initstate_parser_->pre ();

    return true;
  }

  if (n == "simoptions" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->simoptions_parser_;

    if (this->simoptions_parser_)
      this->simoptions_parser_->pre ();

    return true;
  }

  return false;
}

bool SimParameters_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "durstep" && ns.empty ())
  {
    if (this->durstep_parser_)
    {
      this->durstep_parser_->post_durstep ();
      this->durstep ();
    }

    return true;
  }

  if (n == "ORB_initstate" && ns.empty ())
  {
    if (this->ORB_initstate_parser_)
    {
      this->ORB_initstate_parser_->post_ORB_initstate ();
      this->ORB_initstate ();
    }

    return true;
  }

  if (n == "ATT_initstate" && ns.empty ())
  {
    if (this->ATT_initstate_parser_)
    {
      this->ATT_initstate_parser_->post_ATT_initstate ();
      this->ATT_initstate ();
    }

    return true;
  }

  if (n == "simoptions" && ns.empty ())
  {
    if (this->simoptions_parser_)
    {
      this->simoptions_parser_->post_simoptions ();
      this->simoptions ();
    }

    return true;
  }

  return false;
}

// durstep_pskel
//

void durstep_pskel::
simstep (const ::xml_schema::duration&)
{
}

void durstep_pskel::
simduration (const ::xml_schema::duration&)
{
}

void durstep_pskel::
post_durstep ()
{
}

bool durstep_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "simstep" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->simstep_parser_;

    if (this->simstep_parser_)
      this->simstep_parser_->pre ();

    return true;
  }

  if (n == "simduration" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->simduration_parser_;

    if (this->simduration_parser_)
      this->simduration_parser_->pre ();

    return true;
  }

  return false;
}

bool durstep_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "simstep" && ns.empty ())
  {
    if (this->simstep_parser_)
      this->simstep (this->simstep_parser_->post_duration ());

    return true;
  }

  if (n == "simduration" && ns.empty ())
  {
    if (this->simduration_parser_)
      this->simduration (this->simduration_parser_->post_duration ());

    return true;
  }

  return false;
}

// ORB_initstate_pskel
//

void ORB_initstate_pskel::
Initime (const ::xml_schema::date_time&)
{
}

void ORB_initstate_pskel::
Position ()
{
}

void ORB_initstate_pskel::
Velocity ()
{
}

void ORB_initstate_pskel::
post_ORB_initstate ()
{
}

bool ORB_initstate_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "Initime" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->Initime_parser_;

    if (this->Initime_parser_)
      this->Initime_parser_->pre ();

    return true;
  }

  if (n == "Position" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->Position_parser_;

    if (this->Position_parser_)
      this->Position_parser_->pre ();

    return true;
  }

  if (n == "Velocity" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->Velocity_parser_;

    if (this->Velocity_parser_)
      this->Velocity_parser_->pre ();

    return true;
  }

  return false;
}

bool ORB_initstate_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "Initime" && ns.empty ())
  {
    if (this->Initime_parser_)
      this->Initime (this->Initime_parser_->post_date_time ());

    return true;
  }

  if (n == "Position" && ns.empty ())
  {
    if (this->Position_parser_)
    {
      this->Position_parser_->post_posV ();
      this->Position ();
    }

    return true;
  }

  if (n == "Velocity" && ns.empty ())
  {
    if (this->Velocity_parser_)
    {
      this->Velocity_parser_->post_velV ();
      this->Velocity ();
    }

    return true;
  }

  return false;
}

// ATT_initstate_pskel
//

void ATT_initstate_pskel::
phi ()
{
}

void ATT_initstate_pskel::
theta ()
{
}

void ATT_initstate_pskel::
psi ()
{
}

void ATT_initstate_pskel::
om_x ()
{
}

void ATT_initstate_pskel::
om_y ()
{
}

void ATT_initstate_pskel::
om_z ()
{
}

void ATT_initstate_pskel::
post_ATT_initstate ()
{
}

bool ATT_initstate_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "phi" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->phi_parser_;

    if (this->phi_parser_)
      this->phi_parser_->pre ();

    return true;
  }

  if (n == "theta" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->theta_parser_;

    if (this->theta_parser_)
      this->theta_parser_->pre ();

    return true;
  }

  if (n == "psi" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->psi_parser_;

    if (this->psi_parser_)
      this->psi_parser_->pre ();

    return true;
  }

  if (n == "om_x" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->om_x_parser_;

    if (this->om_x_parser_)
      this->om_x_parser_->pre ();

    return true;
  }

  if (n == "om_y" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->om_y_parser_;

    if (this->om_y_parser_)
      this->om_y_parser_->pre ();

    return true;
  }

  if (n == "om_z" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->om_z_parser_;

    if (this->om_z_parser_)
      this->om_z_parser_->pre ();

    return true;
  }

  return false;
}

bool ATT_initstate_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "phi" && ns.empty ())
  {
    if (this->phi_parser_)
    {
      this->phi_parser_->post_Angle ();
      this->phi ();
    }

    return true;
  }

  if (n == "theta" && ns.empty ())
  {
    if (this->theta_parser_)
    {
      this->theta_parser_->post_Angle ();
      this->theta ();
    }

    return true;
  }

  if (n == "psi" && ns.empty ())
  {
    if (this->psi_parser_)
    {
      this->psi_parser_->post_Angle ();
      this->psi ();
    }

    return true;
  }

  if (n == "om_x" && ns.empty ())
  {
    if (this->om_x_parser_)
    {
      this->om_x_parser_->post_Angle ();
      this->om_x ();
    }

    return true;
  }

  if (n == "om_y" && ns.empty ())
  {
    if (this->om_y_parser_)
    {
      this->om_y_parser_->post_Angle ();
      this->om_y ();
    }

    return true;
  }

  if (n == "om_z" && ns.empty ())
  {
    if (this->om_z_parser_)
    {
      this->om_z_parser_->post_Angle ();
      this->om_z ();
    }

    return true;
  }

  return false;
}

// simoptions_pskel
//

void simoptions_pskel::
initstate_in_RTN (bool)
{
}

void simoptions_pskel::
realtime (bool)
{
}

void simoptions_pskel::
realtime_wait ()
{
}

void simoptions_pskel::
ggrad_on (bool)
{
}

void simoptions_pskel::
mag_on (bool)
{
}

void simoptions_pskel::
srp_on (bool)
{
}

void simoptions_pskel::
drag_on (bool)
{
}

void simoptions_pskel::
nMAX ()
{
}

void simoptions_pskel::
sunmoon_on (bool)
{
}

void simoptions_pskel::
Drag_Model (const ::std::string&)
{
}

void simoptions_pskel::
SRP_Model (const ::std::string&)
{
}

void simoptions_pskel::
AttitudeType (const ::std::string&)
{
}

void simoptions_pskel::
attctrl_on (bool)
{
}

void simoptions_pskel::
AttCtrlType (const ::std::string&)
{
}

void simoptions_pskel::
orbctrl_on (bool)
{
}

void simoptions_pskel::
OrbCtrlType (const ::std::string&)
{
}

void simoptions_pskel::
post_simoptions ()
{
}

bool simoptions_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "initstate_in_RTN" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->initstate_in_RTN_parser_;

    if (this->initstate_in_RTN_parser_)
      this->initstate_in_RTN_parser_->pre ();

    return true;
  }

  if (n == "realtime" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->realtime_parser_;

    if (this->realtime_parser_)
      this->realtime_parser_->pre ();

    return true;
  }

  if (n == "realtime_wait" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->realtime_wait_parser_;

    if (this->realtime_wait_parser_)
      this->realtime_wait_parser_->pre ();

    return true;
  }

  if (n == "ggrad_on" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->ggrad_on_parser_;

    if (this->ggrad_on_parser_)
      this->ggrad_on_parser_->pre ();

    return true;
  }

  if (n == "mag_on" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->mag_on_parser_;

    if (this->mag_on_parser_)
      this->mag_on_parser_->pre ();

    return true;
  }

  if (n == "srp_on" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->srp_on_parser_;

    if (this->srp_on_parser_)
      this->srp_on_parser_->pre ();

    return true;
  }

  if (n == "drag_on" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->drag_on_parser_;

    if (this->drag_on_parser_)
      this->drag_on_parser_->pre ();

    return true;
  }

  if (n == "nMAX" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->nMAX_parser_;

    if (this->nMAX_parser_)
      this->nMAX_parser_->pre ();

    return true;
  }

  if (n == "sunmoon_on" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->sunmoon_on_parser_;

    if (this->sunmoon_on_parser_)
      this->sunmoon_on_parser_->pre ();

    return true;
  }

  if (n == "Drag_Model" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->Drag_Model_parser_;

    if (this->Drag_Model_parser_)
      this->Drag_Model_parser_->pre ();

    return true;
  }

  if (n == "SRP_Model" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->SRP_Model_parser_;

    if (this->SRP_Model_parser_)
      this->SRP_Model_parser_->pre ();

    return true;
  }

  if (n == "AttitudeType" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->AttitudeType_parser_;

    if (this->AttitudeType_parser_)
      this->AttitudeType_parser_->pre ();

    return true;
  }

  if (n == "attctrl_on" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->attctrl_on_parser_;

    if (this->attctrl_on_parser_)
      this->attctrl_on_parser_->pre ();

    return true;
  }

  if (n == "AttCtrlType" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->AttCtrlType_parser_;

    if (this->AttCtrlType_parser_)
      this->AttCtrlType_parser_->pre ();

    return true;
  }

  if (n == "orbctrl_on" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->orbctrl_on_parser_;

    if (this->orbctrl_on_parser_)
      this->orbctrl_on_parser_->pre ();

    return true;
  }

  if (n == "OrbCtrlType" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->OrbCtrlType_parser_;

    if (this->OrbCtrlType_parser_)
      this->OrbCtrlType_parser_->pre ();

    return true;
  }

  return false;
}

bool simoptions_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "initstate_in_RTN" && ns.empty ())
  {
    if (this->initstate_in_RTN_parser_)
      this->initstate_in_RTN (this->initstate_in_RTN_parser_->post_boolean ());

    return true;
  }

  if (n == "realtime" && ns.empty ())
  {
    if (this->realtime_parser_)
      this->realtime (this->realtime_parser_->post_boolean ());

    return true;
  }

  if (n == "realtime_wait" && ns.empty ())
  {
    if (this->realtime_wait_parser_)
    {
      this->realtime_wait_parser_->post_Dimensioned ();
      this->realtime_wait ();
    }

    return true;
  }

  if (n == "ggrad_on" && ns.empty ())
  {
    if (this->ggrad_on_parser_)
      this->ggrad_on (this->ggrad_on_parser_->post_boolean ());

    return true;
  }

  if (n == "mag_on" && ns.empty ())
  {
    if (this->mag_on_parser_)
      this->mag_on (this->mag_on_parser_->post_boolean ());

    return true;
  }

  if (n == "srp_on" && ns.empty ())
  {
    if (this->srp_on_parser_)
      this->srp_on (this->srp_on_parser_->post_boolean ());

    return true;
  }

  if (n == "drag_on" && ns.empty ())
  {
    if (this->drag_on_parser_)
      this->drag_on (this->drag_on_parser_->post_boolean ());

    return true;
  }

  if (n == "nMAX" && ns.empty ())
  {
    if (this->nMAX_parser_)
    {
      this->nMAX_parser_->post_nMAX ();
      this->nMAX ();
    }

    return true;
  }

  if (n == "sunmoon_on" && ns.empty ())
  {
    if (this->sunmoon_on_parser_)
      this->sunmoon_on (this->sunmoon_on_parser_->post_boolean ());

    return true;
  }

  if (n == "Drag_Model" && ns.empty ())
  {
    if (this->Drag_Model_parser_)
      this->Drag_Model (this->Drag_Model_parser_->post_string ());

    return true;
  }

  if (n == "SRP_Model" && ns.empty ())
  {
    if (this->SRP_Model_parser_)
      this->SRP_Model (this->SRP_Model_parser_->post_string ());

    return true;
  }

  if (n == "AttitudeType" && ns.empty ())
  {
    if (this->AttitudeType_parser_)
      this->AttitudeType (this->AttitudeType_parser_->post_string ());

    return true;
  }

  if (n == "attctrl_on" && ns.empty ())
  {
    if (this->attctrl_on_parser_)
      this->attctrl_on (this->attctrl_on_parser_->post_boolean ());

    return true;
  }

  if (n == "AttCtrlType" && ns.empty ())
  {
    if (this->AttCtrlType_parser_)
      this->AttCtrlType (this->AttCtrlType_parser_->post_string ());

    return true;
  }

  if (n == "orbctrl_on" && ns.empty ())
  {
    if (this->orbctrl_on_parser_)
      this->orbctrl_on (this->orbctrl_on_parser_->post_boolean ());

    return true;
  }

  if (n == "OrbCtrlType" && ns.empty ())
  {
    if (this->OrbCtrlType_parser_)
      this->OrbCtrlType (this->OrbCtrlType_parser_->post_string ());

    return true;
  }

  return false;
}

// InputFiles_pskel
//

void InputFiles_pskel::
Orbit_ephemeris (const ::std::string&)
{
}

void InputFiles_pskel::
Attitude_ephemeris (const ::std::string&)
{
}

void InputFiles_pskel::
TLE (const ::std::string&)
{
}

void InputFiles_pskel::
Data_path (const ::std::string&)
{
}

void InputFiles_pskel::
Planet_ephemeris (const ::std::string&)
{
}

void InputFiles_pskel::
EOP_parameters (const ::std::string&)
{
}

void InputFiles_pskel::
PCK_data (const ::std::string&)
{
}

void InputFiles_pskel::
Leap_second (const ::std::string&)
{
}

void InputFiles_pskel::
Gravity_model (const ::std::string&)
{
}

void InputFiles_pskel::
Atmospheric_model (const ::std::string&)
{
}

void InputFiles_pskel::
Magnetic_model (const ::std::string&)
{
}

void InputFiles_pskel::
SunMoon_model (const ::std::string&)
{
}

void InputFiles_pskel::
name (const ::std::string&)
{
}

void InputFiles_pskel::
post_InputFiles ()
{
}

bool InputFiles_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "Orbit_ephemeris" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->Orbit_ephemeris_parser_;

    if (this->Orbit_ephemeris_parser_)
      this->Orbit_ephemeris_parser_->pre ();

    return true;
  }

  if (n == "Attitude_ephemeris" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->Attitude_ephemeris_parser_;

    if (this->Attitude_ephemeris_parser_)
      this->Attitude_ephemeris_parser_->pre ();

    return true;
  }

  if (n == "TLE" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->TLE_parser_;

    if (this->TLE_parser_)
      this->TLE_parser_->pre ();

    return true;
  }

  if (n == "Data_path" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->Data_path_parser_;

    if (this->Data_path_parser_)
      this->Data_path_parser_->pre ();

    return true;
  }

  if (n == "Planet_ephemeris" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->Planet_ephemeris_parser_;

    if (this->Planet_ephemeris_parser_)
      this->Planet_ephemeris_parser_->pre ();

    return true;
  }

  if (n == "EOP_parameters" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->EOP_parameters_parser_;

    if (this->EOP_parameters_parser_)
      this->EOP_parameters_parser_->pre ();

    return true;
  }

  if (n == "PCK_data" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->PCK_data_parser_;

    if (this->PCK_data_parser_)
      this->PCK_data_parser_->pre ();

    return true;
  }

  if (n == "Leap_second" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->Leap_second_parser_;

    if (this->Leap_second_parser_)
      this->Leap_second_parser_->pre ();

    return true;
  }

  if (n == "Gravity_model" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->Gravity_model_parser_;

    if (this->Gravity_model_parser_)
      this->Gravity_model_parser_->pre ();

    return true;
  }

  if (n == "Atmospheric_model" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->Atmospheric_model_parser_;

    if (this->Atmospheric_model_parser_)
      this->Atmospheric_model_parser_->pre ();

    return true;
  }

  if (n == "Magnetic_model" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->Magnetic_model_parser_;

    if (this->Magnetic_model_parser_)
      this->Magnetic_model_parser_->pre ();

    return true;
  }

  if (n == "SunMoon_model" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->SunMoon_model_parser_;

    if (this->SunMoon_model_parser_)
      this->SunMoon_model_parser_->pre ();

    return true;
  }

  return false;
}

bool InputFiles_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "Orbit_ephemeris" && ns.empty ())
  {
    if (this->Orbit_ephemeris_parser_)
      this->Orbit_ephemeris (this->Orbit_ephemeris_parser_->post_string ());

    return true;
  }

  if (n == "Attitude_ephemeris" && ns.empty ())
  {
    if (this->Attitude_ephemeris_parser_)
      this->Attitude_ephemeris (this->Attitude_ephemeris_parser_->post_string ());

    return true;
  }

  if (n == "TLE" && ns.empty ())
  {
    if (this->TLE_parser_)
      this->TLE (this->TLE_parser_->post_string ());

    return true;
  }

  if (n == "Data_path" && ns.empty ())
  {
    if (this->Data_path_parser_)
      this->Data_path (this->Data_path_parser_->post_string ());

    return true;
  }

  if (n == "Planet_ephemeris" && ns.empty ())
  {
    if (this->Planet_ephemeris_parser_)
      this->Planet_ephemeris (this->Planet_ephemeris_parser_->post_string ());

    return true;
  }

  if (n == "EOP_parameters" && ns.empty ())
  {
    if (this->EOP_parameters_parser_)
      this->EOP_parameters (this->EOP_parameters_parser_->post_string ());

    return true;
  }

  if (n == "PCK_data" && ns.empty ())
  {
    if (this->PCK_data_parser_)
      this->PCK_data (this->PCK_data_parser_->post_string ());

    return true;
  }

  if (n == "Leap_second" && ns.empty ())
  {
    if (this->Leap_second_parser_)
      this->Leap_second (this->Leap_second_parser_->post_string ());

    return true;
  }

  if (n == "Gravity_model" && ns.empty ())
  {
    if (this->Gravity_model_parser_)
      this->Gravity_model (this->Gravity_model_parser_->post_string ());

    return true;
  }

  if (n == "Atmospheric_model" && ns.empty ())
  {
    if (this->Atmospheric_model_parser_)
      this->Atmospheric_model (this->Atmospheric_model_parser_->post_string ());

    return true;
  }

  if (n == "Magnetic_model" && ns.empty ())
  {
    if (this->Magnetic_model_parser_)
      this->Magnetic_model (this->Magnetic_model_parser_->post_string ());

    return true;
  }

  if (n == "SunMoon_model" && ns.empty ())
  {
    if (this->SunMoon_model_parser_)
      this->SunMoon_model (this->SunMoon_model_parser_->post_string ());

    return true;
  }

  return false;
}

bool InputFiles_pskel::
_attribute_impl (const ::xml_schema::ro_string& ns,
                 const ::xml_schema::ro_string& n,
                 const ::xml_schema::ro_string& v)
{
  if (this->::xml_schema::complex_content::_attribute_impl (ns, n, v))
    return true;

  if (n == "name" && ns.empty ())
  {
    if (this->name_parser_)
    {
      this->name_parser_->pre ();
      this->name_parser_->_pre_impl ();
      this->name_parser_->_characters (v);
      this->name_parser_->_post_impl ();
      this->name (this->name_parser_->post_string ());
    }

    return true;
  }

  return false;
}

// OutputFiles_pskel
//

void OutputFiles_pskel::
Orbit_ephemeris (const ::std::string&)
{
}

void OutputFiles_pskel::
Attitude_ephemeris (const ::std::string&)
{
}

void OutputFiles_pskel::
Sensor_output (const ::std::string&)
{
}

void OutputFiles_pskel::
Torques (const ::std::string&)
{
}

void OutputFiles_pskel::
Accelerations (const ::std::string&)
{
}

void OutputFiles_pskel::
name (const ::std::string&)
{
}

void OutputFiles_pskel::
post_OutputFiles ()
{
}

bool OutputFiles_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "Orbit_ephemeris" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->Orbit_ephemeris_parser_;

    if (this->Orbit_ephemeris_parser_)
      this->Orbit_ephemeris_parser_->pre ();

    return true;
  }

  if (n == "Attitude_ephemeris" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->Attitude_ephemeris_parser_;

    if (this->Attitude_ephemeris_parser_)
      this->Attitude_ephemeris_parser_->pre ();

    return true;
  }

  if (n == "Sensor_output" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->Sensor_output_parser_;

    if (this->Sensor_output_parser_)
      this->Sensor_output_parser_->pre ();

    return true;
  }

  if (n == "Torques" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->Torques_parser_;

    if (this->Torques_parser_)
      this->Torques_parser_->pre ();

    return true;
  }

  if (n == "Accelerations" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->Accelerations_parser_;

    if (this->Accelerations_parser_)
      this->Accelerations_parser_->pre ();

    return true;
  }

  return false;
}

bool OutputFiles_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "Orbit_ephemeris" && ns.empty ())
  {
    if (this->Orbit_ephemeris_parser_)
      this->Orbit_ephemeris (this->Orbit_ephemeris_parser_->post_string ());

    return true;
  }

  if (n == "Attitude_ephemeris" && ns.empty ())
  {
    if (this->Attitude_ephemeris_parser_)
      this->Attitude_ephemeris (this->Attitude_ephemeris_parser_->post_string ());

    return true;
  }

  if (n == "Sensor_output" && ns.empty ())
  {
    if (this->Sensor_output_parser_)
      this->Sensor_output (this->Sensor_output_parser_->post_string ());

    return true;
  }

  if (n == "Torques" && ns.empty ())
  {
    if (this->Torques_parser_)
      this->Torques (this->Torques_parser_->post_string ());

    return true;
  }

  if (n == "Accelerations" && ns.empty ())
  {
    if (this->Accelerations_parser_)
      this->Accelerations (this->Accelerations_parser_->post_string ());

    return true;
  }

  return false;
}

bool OutputFiles_pskel::
_attribute_impl (const ::xml_schema::ro_string& ns,
                 const ::xml_schema::ro_string& n,
                 const ::xml_schema::ro_string& v)
{
  if (this->::xml_schema::complex_content::_attribute_impl (ns, n, v))
    return true;

  if (n == "name" && ns.empty ())
  {
    if (this->name_parser_)
    {
      this->name_parser_->pre ();
      this->name_parser_->_pre_impl ();
      this->name_parser_->_characters (v);
      this->name_parser_->_post_impl ();
      this->name (this->name_parser_->post_string ());
    }

    return true;
  }

  return false;
}

// SensorsActuators_pskel
//

void SensorsActuators_pskel::
subsystem_on (bool)
{
}

void SensorsActuators_pskel::
constparam ()
{
}

void SensorsActuators_pskel::
auxparam ()
{
}

void SensorsActuators_pskel::
opslimit ()
{
}

void SensorsActuators_pskel::
accuracy ()
{
}

void SensorsActuators_pskel::
SC2SYS_matrix ()
{
}

void SensorsActuators_pskel::
name (const ::std::string&)
{
}

void SensorsActuators_pskel::
post_SensorsActuators ()
{
}

bool SensorsActuators_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "subsystem_on" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->subsystem_on_parser_;

    if (this->subsystem_on_parser_)
      this->subsystem_on_parser_->pre ();

    return true;
  }

  if (n == "constparam" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->constparam_parser_;

    if (this->constparam_parser_)
      this->constparam_parser_->pre ();

    return true;
  }

  if (n == "auxparam" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->auxparam_parser_;

    if (this->auxparam_parser_)
      this->auxparam_parser_->pre ();

    return true;
  }

  if (n == "opslimit" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->opslimit_parser_;

    if (this->opslimit_parser_)
      this->opslimit_parser_->pre ();

    return true;
  }

  if (n == "accuracy" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->accuracy_parser_;

    if (this->accuracy_parser_)
      this->accuracy_parser_->pre ();

    return true;
  }

  if (n == "SC2SYS_matrix" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->SC2SYS_matrix_parser_;

    if (this->SC2SYS_matrix_parser_)
      this->SC2SYS_matrix_parser_->pre ();

    return true;
  }

  return false;
}

bool SensorsActuators_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "subsystem_on" && ns.empty ())
  {
    if (this->subsystem_on_parser_)
      this->subsystem_on (this->subsystem_on_parser_->post_boolean ());

    return true;
  }

  if (n == "constparam" && ns.empty ())
  {
    if (this->constparam_parser_)
    {
      this->constparam_parser_->post_constparam ();
      this->constparam ();
    }

    return true;
  }

  if (n == "auxparam" && ns.empty ())
  {
    if (this->auxparam_parser_)
    {
      this->auxparam_parser_->post_auxparam ();
      this->auxparam ();
    }

    return true;
  }

  if (n == "opslimit" && ns.empty ())
  {
    if (this->opslimit_parser_)
    {
      this->opslimit_parser_->post_opslimit ();
      this->opslimit ();
    }

    return true;
  }

  if (n == "accuracy" && ns.empty ())
  {
    if (this->accuracy_parser_)
    {
      this->accuracy_parser_->post_accuracy ();
      this->accuracy ();
    }

    return true;
  }

  if (n == "SC2SYS_matrix" && ns.empty ())
  {
    if (this->SC2SYS_matrix_parser_)
    {
      this->SC2SYS_matrix_parser_->post_RotationMatrix_3x3 ();
      this->SC2SYS_matrix ();
    }

    return true;
  }

  return false;
}

bool SensorsActuators_pskel::
_attribute_impl (const ::xml_schema::ro_string& ns,
                 const ::xml_schema::ro_string& n,
                 const ::xml_schema::ro_string& v)
{
  if (this->::xml_schema::complex_content::_attribute_impl (ns, n, v))
    return true;

  if (n == "name" && ns.empty ())
  {
    if (this->name_parser_)
    {
      this->name_parser_->pre ();
      this->name_parser_->_pre_impl ();
      this->name_parser_->_characters (v);
      this->name_parser_->_post_impl ();
      this->name (this->name_parser_->post_string ());
    }

    return true;
  }

  return false;
}

// constparam_pskel
//

void constparam_pskel::
name (const ::std::string&)
{
}

void constparam_pskel::
unit (const ::std::string&)
{
}

void constparam_pskel::
post_constparam ()
{
}

bool constparam_pskel::
_attribute_impl (const ::xml_schema::ro_string& ns,
                 const ::xml_schema::ro_string& n,
                 const ::xml_schema::ro_string& v)
{
  if (this->::xml_schema::double_pskel::_attribute_impl (ns, n, v))
    return true;

  if (n == "name" && ns.empty ())
  {
    if (this->name_parser_)
    {
      this->name_parser_->pre ();
      this->name_parser_->_pre_impl ();
      this->name_parser_->_characters (v);
      this->name_parser_->_post_impl ();
      this->name (this->name_parser_->post_string ());
    }

    return true;
  }

  if (n == "unit" && ns.empty ())
  {
    if (this->unit_parser_)
    {
      this->unit_parser_->pre ();
      this->unit_parser_->_pre_impl ();
      this->unit_parser_->_characters (v);
      this->unit_parser_->_post_impl ();
      this->unit (this->unit_parser_->post_string ());
    }

    return true;
  }

  return false;
}

// auxparam_pskel
//

void auxparam_pskel::
name (const ::std::string&)
{
}

void auxparam_pskel::
unit (const ::std::string&)
{
}

void auxparam_pskel::
post_auxparam ()
{
}

bool auxparam_pskel::
_attribute_impl (const ::xml_schema::ro_string& ns,
                 const ::xml_schema::ro_string& n,
                 const ::xml_schema::ro_string& v)
{
  if (this->::xml_schema::double_pskel::_attribute_impl (ns, n, v))
    return true;

  if (n == "name" && ns.empty ())
  {
    if (this->name_parser_)
    {
      this->name_parser_->pre ();
      this->name_parser_->_pre_impl ();
      this->name_parser_->_characters (v);
      this->name_parser_->_post_impl ();
      this->name (this->name_parser_->post_string ());
    }

    return true;
  }

  if (n == "unit" && ns.empty ())
  {
    if (this->unit_parser_)
    {
      this->unit_parser_->pre ();
      this->unit_parser_->_pre_impl ();
      this->unit_parser_->_characters (v);
      this->unit_parser_->_post_impl ();
      this->unit (this->unit_parser_->post_string ());
    }

    return true;
  }

  return false;
}

// opslimit_pskel
//

void opslimit_pskel::
name (const ::std::string&)
{
}

void opslimit_pskel::
unit (const ::std::string&)
{
}

void opslimit_pskel::
post_opslimit ()
{
}

bool opslimit_pskel::
_attribute_impl (const ::xml_schema::ro_string& ns,
                 const ::xml_schema::ro_string& n,
                 const ::xml_schema::ro_string& v)
{
  if (this->::xml_schema::double_pskel::_attribute_impl (ns, n, v))
    return true;

  if (n == "name" && ns.empty ())
  {
    if (this->name_parser_)
    {
      this->name_parser_->pre ();
      this->name_parser_->_pre_impl ();
      this->name_parser_->_characters (v);
      this->name_parser_->_post_impl ();
      this->name (this->name_parser_->post_string ());
    }

    return true;
  }

  if (n == "unit" && ns.empty ())
  {
    if (this->unit_parser_)
    {
      this->unit_parser_->pre ();
      this->unit_parser_->_pre_impl ();
      this->unit_parser_->_characters (v);
      this->unit_parser_->_post_impl ();
      this->unit (this->unit_parser_->post_string ());
    }

    return true;
  }

  return false;
}

// accuracy_pskel
//

void accuracy_pskel::
name (const ::std::string&)
{
}

void accuracy_pskel::
unit (const ::std::string&)
{
}

void accuracy_pskel::
post_accuracy ()
{
}

bool accuracy_pskel::
_attribute_impl (const ::xml_schema::ro_string& ns,
                 const ::xml_schema::ro_string& n,
                 const ::xml_schema::ro_string& v)
{
  if (this->::xml_schema::double_pskel::_attribute_impl (ns, n, v))
    return true;

  if (n == "name" && ns.empty ())
  {
    if (this->name_parser_)
    {
      this->name_parser_->pre ();
      this->name_parser_->_pre_impl ();
      this->name_parser_->_characters (v);
      this->name_parser_->_post_impl ();
      this->name (this->name_parser_->post_string ());
    }

    return true;
  }

  if (n == "unit" && ns.empty ())
  {
    if (this->unit_parser_)
    {
      this->unit_parser_->pre ();
      this->unit_parser_->_pre_impl ();
      this->unit_parser_->_characters (v);
      this->unit_parser_->_post_impl ();
      this->unit (this->unit_parser_->post_string ());
    }

    return true;
  }

  return false;
}

// Maneuvers_pskel
//

void Maneuvers_pskel::
Man ()
{
}

void Maneuvers_pskel::
post_Maneuvers ()
{
}

bool Maneuvers_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "Man" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->Man_parser_;

    if (this->Man_parser_)
      this->Man_parser_->pre ();

    return true;
  }

  return false;
}

bool Maneuvers_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "Man" && ns.empty ())
  {
    if (this->Man_parser_)
    {
      this->Man_parser_->post_Man ();
      this->Man ();
    }

    return true;
  }

  return false;
}

// Man_pskel
//

void Man_pskel::
maneuver_on (bool)
{
}

void Man_pskel::
init_time (double)
{
}

void Man_pskel::
duration (double)
{
}

void Man_pskel::
ManVec ()
{
}

void Man_pskel::
name ()
{
}

void Man_pskel::
post_Man ()
{
}

bool Man_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "maneuver_on" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->maneuver_on_parser_;

    if (this->maneuver_on_parser_)
      this->maneuver_on_parser_->pre ();

    return true;
  }

  if (n == "init_time" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->init_time_parser_;

    if (this->init_time_parser_)
      this->init_time_parser_->pre ();

    return true;
  }

  if (n == "duration" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->duration_parser_;

    if (this->duration_parser_)
      this->duration_parser_->pre ();

    return true;
  }

  if (n == "ManVec" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->ManVec_parser_;

    if (this->ManVec_parser_)
      this->ManVec_parser_->pre ();

    return true;
  }

  return false;
}

bool Man_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "maneuver_on" && ns.empty ())
  {
    if (this->maneuver_on_parser_)
      this->maneuver_on (this->maneuver_on_parser_->post_boolean ());

    return true;
  }

  if (n == "init_time" && ns.empty ())
  {
    if (this->init_time_parser_)
      this->init_time (this->init_time_parser_->post_double ());

    return true;
  }

  if (n == "duration" && ns.empty ())
  {
    if (this->duration_parser_)
      this->duration (this->duration_parser_->post_double ());

    return true;
  }

  if (n == "ManVec" && ns.empty ())
  {
    if (this->ManVec_parser_)
    {
      this->ManVec_parser_->post_Vector ();
      this->ManVec ();
    }

    return true;
  }

  return false;
}

bool Man_pskel::
_attribute_impl (const ::xml_schema::ro_string& ns,
                 const ::xml_schema::ro_string& n,
                 const ::xml_schema::ro_string& v)
{
  if (this->::xml_schema::complex_content::_attribute_impl (ns, n, v))
    return true;

  if (n == "name" && ns.empty ())
  {
    if (this->name_parser_)
    {
      this->name_parser_->pre ();
      this->name_parser_->_pre_impl ();
      this->name_parser_->_characters (v);
      this->name_parser_->_post_impl ();
      this->name_parser_->post_name ();
      this->name ();
    }

    return true;
  }

  return false;
}

// CompParameters_pskel
//

void CompParameters_pskel::
durstep ()
{
}

void CompParameters_pskel::
Payload ()
{
}

void CompParameters_pskel::
Spacecraft ()
{
}

void CompParameters_pskel::
Compoptions ()
{
}

void CompParameters_pskel::
post_CompParameters ()
{
}

bool CompParameters_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "durstep" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->durstep_parser_;

    if (this->durstep_parser_)
      this->durstep_parser_->pre ();

    return true;
  }

  if (n == "Payload" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->Payload_parser_;

    if (this->Payload_parser_)
      this->Payload_parser_->pre ();

    return true;
  }

  if (n == "Spacecraft" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->Spacecraft_parser_;

    if (this->Spacecraft_parser_)
      this->Spacecraft_parser_->pre ();

    return true;
  }

  if (n == "Compoptions" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->Compoptions_parser_;

    if (this->Compoptions_parser_)
      this->Compoptions_parser_->pre ();

    return true;
  }

  return false;
}

bool CompParameters_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "durstep" && ns.empty ())
  {
    if (this->durstep_parser_)
    {
      this->durstep_parser_->post_durstep ();
      this->durstep ();
    }

    return true;
  }

  if (n == "Payload" && ns.empty ())
  {
    if (this->Payload_parser_)
    {
      this->Payload_parser_->post_Payload ();
      this->Payload ();
    }

    return true;
  }

  if (n == "Spacecraft" && ns.empty ())
  {
    if (this->Spacecraft_parser_)
    {
      this->Spacecraft_parser_->post_Spacecraft ();
      this->Spacecraft ();
    }

    return true;
  }

  if (n == "Compoptions" && ns.empty ())
  {
    if (this->Compoptions_parser_)
    {
      this->Compoptions_parser_->post_Compoptions ();
      this->Compoptions ();
    }

    return true;
  }

  return false;
}

// Payload_pskel
//

void Payload_pskel::
FOV_cross ()
{
}

void Payload_pskel::
FOV_along ()
{
}

void Payload_pskel::
post_Payload ()
{
}

bool Payload_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "FOV_cross" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->FOV_cross_parser_;

    if (this->FOV_cross_parser_)
      this->FOV_cross_parser_->pre ();

    return true;
  }

  if (n == "FOV_along" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->FOV_along_parser_;

    if (this->FOV_along_parser_)
      this->FOV_along_parser_->pre ();

    return true;
  }

  return false;
}

bool Payload_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "FOV_cross" && ns.empty ())
  {
    if (this->FOV_cross_parser_)
    {
      this->FOV_cross_parser_->post_Angle ();
      this->FOV_cross ();
    }

    return true;
  }

  if (n == "FOV_along" && ns.empty ())
  {
    if (this->FOV_along_parser_)
    {
      this->FOV_along_parser_->post_Angle ();
      this->FOV_along ();
    }

    return true;
  }

  return false;
}

// Spacecraft_pskel
//

void Spacecraft_pskel::
SC_start (unsigned long long)
{
}

void Spacecraft_pskel::
SC_end (unsigned long long)
{
}

void Spacecraft_pskel::
PL_start (unsigned long long)
{
}

void Spacecraft_pskel::
PL_end (unsigned long long)
{
}

void Spacecraft_pskel::
post_Spacecraft ()
{
}

bool Spacecraft_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "SC_start" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->SC_start_parser_;

    if (this->SC_start_parser_)
      this->SC_start_parser_->pre ();

    return true;
  }

  if (n == "SC_end" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->SC_end_parser_;

    if (this->SC_end_parser_)
      this->SC_end_parser_->pre ();

    return true;
  }

  if (n == "PL_start" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->PL_start_parser_;

    if (this->PL_start_parser_)
      this->PL_start_parser_->pre ();

    return true;
  }

  if (n == "PL_end" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->PL_end_parser_;

    if (this->PL_end_parser_)
      this->PL_end_parser_->pre ();

    return true;
  }

  return false;
}

bool Spacecraft_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "SC_start" && ns.empty ())
  {
    if (this->SC_start_parser_)
      this->SC_start (this->SC_start_parser_->post_positive_integer ());

    return true;
  }

  if (n == "SC_end" && ns.empty ())
  {
    if (this->SC_end_parser_)
      this->SC_end (this->SC_end_parser_->post_positive_integer ());

    return true;
  }

  if (n == "PL_start" && ns.empty ())
  {
    if (this->PL_start_parser_)
      this->PL_start (this->PL_start_parser_->post_positive_integer ());

    return true;
  }

  if (n == "PL_end" && ns.empty ())
  {
    if (this->PL_end_parser_)
      this->PL_end (this->PL_end_parser_->post_positive_integer ());

    return true;
  }

  return false;
}

// Compoptions_pskel
//

void Compoptions_pskel::
TGs_on (bool)
{
}

void Compoptions_pskel::
GSs_on (bool)
{
}

void Compoptions_pskel::
TGs_grid_on (bool)
{
}

void Compoptions_pskel::
Eclipse_on (bool)
{
}

void Compoptions_pskel::
post_Compoptions ()
{
}

bool Compoptions_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "TGs_on" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->TGs_on_parser_;

    if (this->TGs_on_parser_)
      this->TGs_on_parser_->pre ();

    return true;
  }

  if (n == "GSs_on" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->GSs_on_parser_;

    if (this->GSs_on_parser_)
      this->GSs_on_parser_->pre ();

    return true;
  }

  if (n == "TGs_grid_on" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->TGs_grid_on_parser_;

    if (this->TGs_grid_on_parser_)
      this->TGs_grid_on_parser_->pre ();

    return true;
  }

  if (n == "Eclipse_on" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->Eclipse_on_parser_;

    if (this->Eclipse_on_parser_)
      this->Eclipse_on_parser_->pre ();

    return true;
  }

  return false;
}

bool Compoptions_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "TGs_on" && ns.empty ())
  {
    if (this->TGs_on_parser_)
      this->TGs_on (this->TGs_on_parser_->post_boolean ());

    return true;
  }

  if (n == "GSs_on" && ns.empty ())
  {
    if (this->GSs_on_parser_)
      this->GSs_on (this->GSs_on_parser_->post_boolean ());

    return true;
  }

  if (n == "TGs_grid_on" && ns.empty ())
  {
    if (this->TGs_grid_on_parser_)
      this->TGs_grid_on (this->TGs_grid_on_parser_->post_boolean ());

    return true;
  }

  if (n == "Eclipse_on" && ns.empty ())
  {
    if (this->Eclipse_on_parser_)
      this->Eclipse_on (this->Eclipse_on_parser_->post_boolean ());

    return true;
  }

  return false;
}

// TGs_pskel
//

void TGs_pskel::
TGs_grid ()
{
}

void TGs_pskel::
TGs_list ()
{
}

void TGs_pskel::
post_TGs ()
{
}

bool TGs_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "TGs_grid" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->TGs_grid_parser_;

    if (this->TGs_grid_parser_)
      this->TGs_grid_parser_->pre ();

    return true;
  }

  if (n == "TGs_list" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->TGs_list_parser_;

    if (this->TGs_list_parser_)
      this->TGs_list_parser_->pre ();

    return true;
  }

  return false;
}

bool TGs_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "TGs_grid" && ns.empty ())
  {
    if (this->TGs_grid_parser_)
    {
      this->TGs_grid_parser_->post_TGs_grid ();
      this->TGs_grid ();
    }

    return true;
  }

  if (n == "TGs_list" && ns.empty ())
  {
    if (this->TGs_list_parser_)
    {
      this->TGs_list_parser_->post_TGs_list ();
      this->TGs_list ();
    }

    return true;
  }

  return false;
}

// TGs_grid_pskel
//

void TGs_grid_pskel::
minlon ()
{
}

void TGs_grid_pskel::
maxlon ()
{
}

void TGs_grid_pskel::
minlat ()
{
}

void TGs_grid_pskel::
maxlat ()
{
}

void TGs_grid_pskel::
gridstep ()
{
}

void TGs_grid_pskel::
post_TGs_grid ()
{
}

bool TGs_grid_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "minlon" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->minlon_parser_;

    if (this->minlon_parser_)
      this->minlon_parser_->pre ();

    return true;
  }

  if (n == "maxlon" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->maxlon_parser_;

    if (this->maxlon_parser_)
      this->maxlon_parser_->pre ();

    return true;
  }

  if (n == "minlat" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->minlat_parser_;

    if (this->minlat_parser_)
      this->minlat_parser_->pre ();

    return true;
  }

  if (n == "maxlat" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->maxlat_parser_;

    if (this->maxlat_parser_)
      this->maxlat_parser_->pre ();

    return true;
  }

  if (n == "gridstep" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->gridstep_parser_;

    if (this->gridstep_parser_)
      this->gridstep_parser_->pre ();

    return true;
  }

  return false;
}

bool TGs_grid_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "minlon" && ns.empty ())
  {
    if (this->minlon_parser_)
    {
      this->minlon_parser_->post_Angle ();
      this->minlon ();
    }

    return true;
  }

  if (n == "maxlon" && ns.empty ())
  {
    if (this->maxlon_parser_)
    {
      this->maxlon_parser_->post_Angle ();
      this->maxlon ();
    }

    return true;
  }

  if (n == "minlat" && ns.empty ())
  {
    if (this->minlat_parser_)
    {
      this->minlat_parser_->post_Angle ();
      this->minlat ();
    }

    return true;
  }

  if (n == "maxlat" && ns.empty ())
  {
    if (this->maxlat_parser_)
    {
      this->maxlat_parser_->post_Angle ();
      this->maxlat ();
    }

    return true;
  }

  if (n == "gridstep" && ns.empty ())
  {
    if (this->gridstep_parser_)
    {
      this->gridstep_parser_->post_Angle ();
      this->gridstep ();
    }

    return true;
  }

  return false;
}

// TGs_list_pskel
//

void TGs_list_pskel::
TG ()
{
}

void TGs_list_pskel::
post_TGs_list ()
{
}

bool TGs_list_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "TG" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->TG_parser_;

    if (this->TG_parser_)
      this->TG_parser_->pre ();

    return true;
  }

  return false;
}

bool TGs_list_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "TG" && ns.empty ())
  {
    if (this->TG_parser_)
    {
      this->TG_parser_->post_TG ();
      this->TG ();
    }

    return true;
  }

  return false;
}

// TG_pskel
//

void TG_pskel::
lon ()
{
}

void TG_pskel::
lat ()
{
}

void TG_pskel::
alt ()
{
}

void TG_pskel::
name (const ::std::string&)
{
}

void TG_pskel::
post_TG ()
{
}

bool TG_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "lon" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->lon_parser_;

    if (this->lon_parser_)
      this->lon_parser_->pre ();

    return true;
  }

  if (n == "lat" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->lat_parser_;

    if (this->lat_parser_)
      this->lat_parser_->pre ();

    return true;
  }

  if (n == "alt" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->alt_parser_;

    if (this->alt_parser_)
      this->alt_parser_->pre ();

    return true;
  }

  return false;
}

bool TG_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "lon" && ns.empty ())
  {
    if (this->lon_parser_)
    {
      this->lon_parser_->post_Angle ();
      this->lon ();
    }

    return true;
  }

  if (n == "lat" && ns.empty ())
  {
    if (this->lat_parser_)
    {
      this->lat_parser_->post_Angle ();
      this->lat ();
    }

    return true;
  }

  if (n == "alt" && ns.empty ())
  {
    if (this->alt_parser_)
    {
      this->alt_parser_->post_Altitude ();
      this->alt ();
    }

    return true;
  }

  return false;
}

bool TG_pskel::
_attribute_impl (const ::xml_schema::ro_string& ns,
                 const ::xml_schema::ro_string& n,
                 const ::xml_schema::ro_string& v)
{
  if (this->::xml_schema::complex_content::_attribute_impl (ns, n, v))
    return true;

  if (n == "name" && ns.empty ())
  {
    if (this->name_parser_)
    {
      this->name_parser_->pre ();
      this->name_parser_->_pre_impl ();
      this->name_parser_->_characters (v);
      this->name_parser_->_post_impl ();
      this->name (this->name_parser_->post_string ());
    }

    return true;
  }

  return false;
}

// GSs_pskel
//

void GSs_pskel::
GS ()
{
}

void GSs_pskel::
post_GSs ()
{
}

bool GSs_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "GS" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->GS_parser_;

    if (this->GS_parser_)
      this->GS_parser_->pre ();

    return true;
  }

  return false;
}

bool GSs_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "GS" && ns.empty ())
  {
    if (this->GS_parser_)
    {
      this->GS_parser_->post_GS ();
      this->GS ();
    }

    return true;
  }

  return false;
}

// GS_pskel
//

void GS_pskel::
lon ()
{
}

void GS_pskel::
lat ()
{
}

void GS_pskel::
alt ()
{
}

void GS_pskel::
minelev ()
{
}

void GS_pskel::
name (const ::std::string&)
{
}

void GS_pskel::
post_GS ()
{
}

bool GS_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "lon" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->lon_parser_;

    if (this->lon_parser_)
      this->lon_parser_->pre ();

    return true;
  }

  if (n == "lat" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->lat_parser_;

    if (this->lat_parser_)
      this->lat_parser_->pre ();

    return true;
  }

  if (n == "alt" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->alt_parser_;

    if (this->alt_parser_)
      this->alt_parser_->pre ();

    return true;
  }

  if (n == "minelev" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->minelev_parser_;

    if (this->minelev_parser_)
      this->minelev_parser_->pre ();

    return true;
  }

  return false;
}

bool GS_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "lon" && ns.empty ())
  {
    if (this->lon_parser_)
    {
      this->lon_parser_->post_Angle ();
      this->lon ();
    }

    return true;
  }

  if (n == "lat" && ns.empty ())
  {
    if (this->lat_parser_)
    {
      this->lat_parser_->post_Angle ();
      this->lat ();
    }

    return true;
  }

  if (n == "alt" && ns.empty ())
  {
    if (this->alt_parser_)
    {
      this->alt_parser_->post_Altitude ();
      this->alt ();
    }

    return true;
  }

  if (n == "minelev" && ns.empty ())
  {
    if (this->minelev_parser_)
    {
      this->minelev_parser_->post_Angle ();
      this->minelev ();
    }

    return true;
  }

  return false;
}

bool GS_pskel::
_attribute_impl (const ::xml_schema::ro_string& ns,
                 const ::xml_schema::ro_string& n,
                 const ::xml_schema::ro_string& v)
{
  if (this->::xml_schema::complex_content::_attribute_impl (ns, n, v))
    return true;

  if (n == "name" && ns.empty ())
  {
    if (this->name_parser_)
    {
      this->name_parser_->pre ();
      this->name_parser_->_pre_impl ();
      this->name_parser_->_characters (v);
      this->name_parser_->_post_impl ();
      this->name (this->name_parser_->post_string ());
    }

    return true;
  }

  return false;
}

// EventsInputFiles_pskel
//

void EventsInputFiles_pskel::
Orbit_ephemeris_path (const ::std::string&)
{
}

void EventsInputFiles_pskel::
Orbit_ephemeris_rootname (const ::std::string&)
{
}

void EventsInputFiles_pskel::
Data_path (const ::std::string&)
{
}

void EventsInputFiles_pskel::
Planet_ephemeris (const ::std::string&)
{
}

void EventsInputFiles_pskel::
EOP_parameters (const ::std::string&)
{
}

void EventsInputFiles_pskel::
PCK_data (const ::std::string&)
{
}

void EventsInputFiles_pskel::
Leap_second (const ::std::string&)
{
}

void EventsInputFiles_pskel::
name (const ::std::string&)
{
}

void EventsInputFiles_pskel::
post_EventsInputFiles ()
{
}

bool EventsInputFiles_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "Orbit_ephemeris_path" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->Orbit_ephemeris_path_parser_;

    if (this->Orbit_ephemeris_path_parser_)
      this->Orbit_ephemeris_path_parser_->pre ();

    return true;
  }

  if (n == "Orbit_ephemeris_rootname" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->Orbit_ephemeris_rootname_parser_;

    if (this->Orbit_ephemeris_rootname_parser_)
      this->Orbit_ephemeris_rootname_parser_->pre ();

    return true;
  }

  if (n == "Data_path" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->Data_path_parser_;

    if (this->Data_path_parser_)
      this->Data_path_parser_->pre ();

    return true;
  }

  if (n == "Planet_ephemeris" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->Planet_ephemeris_parser_;

    if (this->Planet_ephemeris_parser_)
      this->Planet_ephemeris_parser_->pre ();

    return true;
  }

  if (n == "EOP_parameters" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->EOP_parameters_parser_;

    if (this->EOP_parameters_parser_)
      this->EOP_parameters_parser_->pre ();

    return true;
  }

  if (n == "PCK_data" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->PCK_data_parser_;

    if (this->PCK_data_parser_)
      this->PCK_data_parser_->pre ();

    return true;
  }

  if (n == "Leap_second" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->Leap_second_parser_;

    if (this->Leap_second_parser_)
      this->Leap_second_parser_->pre ();

    return true;
  }

  return false;
}

bool EventsInputFiles_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "Orbit_ephemeris_path" && ns.empty ())
  {
    if (this->Orbit_ephemeris_path_parser_)
      this->Orbit_ephemeris_path (this->Orbit_ephemeris_path_parser_->post_string ());

    return true;
  }

  if (n == "Orbit_ephemeris_rootname" && ns.empty ())
  {
    if (this->Orbit_ephemeris_rootname_parser_)
      this->Orbit_ephemeris_rootname (this->Orbit_ephemeris_rootname_parser_->post_string ());

    return true;
  }

  if (n == "Data_path" && ns.empty ())
  {
    if (this->Data_path_parser_)
      this->Data_path (this->Data_path_parser_->post_string ());

    return true;
  }

  if (n == "Planet_ephemeris" && ns.empty ())
  {
    if (this->Planet_ephemeris_parser_)
      this->Planet_ephemeris (this->Planet_ephemeris_parser_->post_string ());

    return true;
  }

  if (n == "EOP_parameters" && ns.empty ())
  {
    if (this->EOP_parameters_parser_)
      this->EOP_parameters (this->EOP_parameters_parser_->post_string ());

    return true;
  }

  if (n == "PCK_data" && ns.empty ())
  {
    if (this->PCK_data_parser_)
      this->PCK_data (this->PCK_data_parser_->post_string ());

    return true;
  }

  if (n == "Leap_second" && ns.empty ())
  {
    if (this->Leap_second_parser_)
      this->Leap_second (this->Leap_second_parser_->post_string ());

    return true;
  }

  return false;
}

bool EventsInputFiles_pskel::
_attribute_impl (const ::xml_schema::ro_string& ns,
                 const ::xml_schema::ro_string& n,
                 const ::xml_schema::ro_string& v)
{
  if (this->::xml_schema::complex_content::_attribute_impl (ns, n, v))
    return true;

  if (n == "name" && ns.empty ())
  {
    if (this->name_parser_)
    {
      this->name_parser_->pre ();
      this->name_parser_->_pre_impl ();
      this->name_parser_->_characters (v);
      this->name_parser_->_post_impl ();
      this->name (this->name_parser_->post_string ());
    }

    return true;
  }

  return false;
}

// EventsOutputFiles_pskel
//

void EventsOutputFiles_pskel::
TG_contacts (const ::std::string&)
{
}

void EventsOutputFiles_pskel::
GS_contacts (const ::std::string&)
{
}

void EventsOutputFiles_pskel::
Eclipse_times (const ::std::string&)
{
}

void EventsOutputFiles_pskel::
name (const ::std::string&)
{
}

void EventsOutputFiles_pskel::
post_EventsOutputFiles ()
{
}

bool EventsOutputFiles_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "TG_contacts" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->TG_contacts_parser_;

    if (this->TG_contacts_parser_)
      this->TG_contacts_parser_->pre ();

    return true;
  }

  if (n == "GS_contacts" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->GS_contacts_parser_;

    if (this->GS_contacts_parser_)
      this->GS_contacts_parser_->pre ();

    return true;
  }

  if (n == "Eclipse_times" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->Eclipse_times_parser_;

    if (this->Eclipse_times_parser_)
      this->Eclipse_times_parser_->pre ();

    return true;
  }

  return false;
}

bool EventsOutputFiles_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "TG_contacts" && ns.empty ())
  {
    if (this->TG_contacts_parser_)
      this->TG_contacts (this->TG_contacts_parser_->post_string ());

    return true;
  }

  if (n == "GS_contacts" && ns.empty ())
  {
    if (this->GS_contacts_parser_)
      this->GS_contacts (this->GS_contacts_parser_->post_string ());

    return true;
  }

  if (n == "Eclipse_times" && ns.empty ())
  {
    if (this->Eclipse_times_parser_)
      this->Eclipse_times (this->Eclipse_times_parser_->post_string ());

    return true;
  }

  return false;
}

bool EventsOutputFiles_pskel::
_attribute_impl (const ::xml_schema::ro_string& ns,
                 const ::xml_schema::ro_string& n,
                 const ::xml_schema::ro_string& v)
{
  if (this->::xml_schema::complex_content::_attribute_impl (ns, n, v))
    return true;

  if (n == "name" && ns.empty ())
  {
    if (this->name_parser_)
    {
      this->name_parser_->pre ();
      this->name_parser_->_pre_impl ();
      this->name_parser_->_characters (v);
      this->name_parser_->_post_impl ();
      this->name (this->name_parser_->post_string ());
    }

    return true;
  }

  return false;
}

// license_pskel
//

void license_pskel::
licenseName (const ::std::string&)
{
}

void license_pskel::
licenseURL (const ::std::string&)
{
}

void license_pskel::
post_license ()
{
}

bool license_pskel::
_attribute_impl (const ::xml_schema::ro_string& ns,
                 const ::xml_schema::ro_string& n,
                 const ::xml_schema::ro_string& v)
{
  if (this->::xml_schema::complex_content::_attribute_impl (ns, n, v))
    return true;

  if (n == "licenseName" && ns.empty ())
  {
    if (this->licenseName_parser_)
    {
      this->licenseName_parser_->pre ();
      this->licenseName_parser_->_pre_impl ();
      this->licenseName_parser_->_characters (v);
      this->licenseName_parser_->_post_impl ();
      this->licenseName (this->licenseName_parser_->post_string ());
    }

    return true;
  }

  if (n == "licenseURL" && ns.empty ())
  {
    if (this->licenseURL_parser_)
    {
      this->licenseURL_parser_->pre ();
      this->licenseURL_parser_->_pre_impl ();
      this->licenseURL_parser_->_characters (v);
      this->licenseURL_parser_->_post_impl ();
      this->licenseURL (this->licenseURL_parser_->post_uri ());
    }

    return true;
  }

  return false;
}

// name_pskel
//

void name_pskel::
post_name ()
{
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

