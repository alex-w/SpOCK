//==========================================================================
/*
*    Copyright 2020 Sergio De Florio
*    All rigths reserved
*
*    This file is part of SpOCK
* 
*    SpOCK is free software: you can redistribute it and/or modify
*    it under the terms of the GNU General Public License as published by
*    the Free Software Foundation version 3
* 
*    SpOCK is distributed in the hope that it will be useful,
*    but WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
*    GNU General Public License for more details.
* 
*    You should have received a copy of the GNU General Public License
*    along with SpOCK. If not, see <https://www.gnu.org/licenses/>.
*
*/
//==========================================================================

#ifndef PROPAGATOR_H
#define PROPAGATOR_H

#define BOOST_BIND_GLOBAL_PLACEHOLDERS

// External libraries: Eigen
#include <Eigen/Core>

#include <VarTypes.h>


#include <boost/array.hpp>
#include <boost/numeric/odeint.hpp>

//#include <boost/numeric/odeint/stepper/XYZ.hpp>   // Include path for all steppers, XYZ is a placeholder for a stepper
//#include <boost/numeric/odeint/algebra/XYZ.hpp>   // All algebras
//#include <boost/numeric/odeint/util/XYZ.hpp>      // Utility functions like is_resizeable , same_size , or resize
//#include <boost/numeric/odeint/integrate/XYZ.hpp> // Integrate routines.
//#include <boost/numeric/odeint/iterator/XYZ.hpp>  // Range and iterator functions.
//#include <boost/numeric/odeint/external/XYZ.hpp>  // Any binders to external libraries

using namespace boost::numeric::odeint;
using namespace std;
using namespace SC;
using namespace math;
using namespace Eigen;
//template<std::size_t N>
//typedef boost::array< double , N > state_type;

typedef boost::array< double , 6 > state_type;
typedef boost::array< double , 7 > state_typeQ;
//typedef double state_type[6];
//template<std::size_t N>
//using state_type = boost::array<double, N>;
//typedef std::vector<double> state_type;
//runge_kutta4< state_type > stepper;

namespace propagator
   {
    //------------------------------------------------------------------------------
    // \class PROP specification
    //------------------------------------------------------------------------------
    /**
     * Base class for dynamic models propagation
     */
    //------------------------------------------------------------------------------
    class PROP
         {
         public:
         //! Constructors.
         PROP();
         PROP(SC_params& param);
         PROP(SC_params& param, EnvModels& models);
         //! Destructor.
         virtual ~PROP();
         //------------------------------------------------------------------------------
         // Class methods specification
         //------------------------------------------------------------------------------
         // Parameters allocation
         void Setup(SC_params& param);
         // Parameters allocation and environmental models files setup
         void Setup(SC_params& param, EnvModels& models); 
         // Initialization with propagation start epoch and initial state
         void Init(double init_time, const Ref<const VectorXd>& init_state);
         // Initialization with propagation start epoch, initial state and initial orbital state
         void Init(double init_time, const Ref<const VectorXd>& init_state, const Ref<const VectorXd>& orb_state);
         // Setup numerical integrator parameters
         void StepperSetup(double eps_abs, double eps_rel, double factor_x, double factor_dxdt);
         //------------------------------------------------------------------------------
         // Abstract method void ForceModelsSetup()
         //------------------------------------------------------------------------------
         /**
           * Generate force models
           */
         //------------------------------------------------------------------------------  
         virtual void ForceModelsSetup() = 0;
         //------------------------------------------------------------------------------
         // Abstract method void Maneuver(const Ref<const VectorXd>& maneuver)
         //------------------------------------------------------------------------------
         /**
           * Insert the action generated by an actuator (reaction wheel, thruster, etc.)
           *
           * @param maneuver   Maneuver vector (torque, dv, etc.)
           */
         //------------------------------------------------------------------------------  
         virtual void Maneuver(const Ref<const VectorXd>& maneuver) = 0;
         //------------------------------------------------------------------------------
         // Abstract method void ComputeAction(double GPStime, const Ref<const VectorXd>& currentstate, const Ref<const VectorXd>& orb_state)
         //------------------------------------------------------------------------------
         /**
           * Compute the action (acceleration, force, torque, etc.) to be used in the
           * dynamics model of the propagator
           *
           * @param epoch          Epoch of the input states
           * @param currentstate   Dynamic model state vector
           * @param orbstate       Orbital state vector
           */
         //------------------------------------------------------------------------------  
         virtual void ComputeAction(double epoch, const Ref<const VectorXd>& currentstate, const Ref<const VectorXd>& orb_state) = 0;
         //------------------------------------------------------------------------------
         // Abstract method void Integrate(double t, double step)
         //------------------------------------------------------------------------------
         /**
           * Integrate the state vector
           *
           * @param t     Step [s]
           * @param step  Step length [s]
           */
         //------------------------------------------------------------------------------
         virtual void Integrate(double t, double step) = 0;  // Execute fixed step numerical integration
         //------------------------------------------------------------------------------
         // Abstract method void StepperSetup(double eps_abs, double eps_rel, double factor_x, double factor_dxdt)
         //------------------------------------------------------------------------------
         /**
           * Setup numerical integrator parameters
           *
           * @param eps_abs       Absolute tolerance level
           * @param eps_rel       Relative tolerance level
           * @param factor_x      Factor for the weight of the derivative
           * @param factor_dxdt   Factor for the weight of the state
           */
         //------------------------------------------------------------------------------
         
         public:
         /** Spacecraft parameters (@see VarTypes.h).*/
         SC_params SC_Parameters;
         /** Environment models paths (@see VarTypes.h).*/
         EnvModels Models;
         /** Dynamic model initial state vector.*/
         VectorXd initstate;
         /** Dynamic model state vector.*/
         VectorXd state;
         /** Orbital state vector.*/
         VectorXd orbstate;
         /** Propagation duration.*/
         int simdur;
         /** Enable or disable gravity gradient.*/
         bool ggrad_on;
         /** Enable or disable magnetic field.*/
         bool mag_on;
         /** Enable or disable atmospheric drag.*/
         bool drag_on;
         /** Enable or disable solar radiation pressure.*/
         bool srp_on;
         /** Maximum order and degree of gravitational field model used for the orbit propagation.*/
         int nMAX;
         /** Enable or disable third body perturbation.*/
         bool sunmoon_on;
         /** Atmospheric drag model used.*/
         string Drag_Model;
         /** Solar radiation pressure model used.*/
         string SRP_Model;
         
         protected:
         /** Spacecraft mass.*/
         double SC_mass;
         /** Moments of inertia matrix.*/
         static Mat3x3d MoI;
         /** Determinant of moments of inertia matrix.*/
         double detMoI;
         /** Inverse of moments of inertia matrix.*/
         static Mat3x3d invMoI;
         /** Map containing spacecraft surfaces' parameters. The key is the bame of the surface.*/
         map<string, Face> SC_Faces;
         /** Spacecraft's residual magnetic dipole.*/
         Vec3d Mdip;
         /** Spacecraft's atmospheric drag coefficient.*/
         double CD;
         /** Spacecraft's radiation pressure coefficient.*/
         double C_SRP;
         /** Drag area to be used with atmospheric drag simple model.*/
         double Area_D;
         /** Radiation area to be used with solar radiation pressure simple model.*/
         double Area_R;
         /** Path of data folder.*/
         string datapath;
         /** Path of planet ephemeris file.*/
         string planetephem;
         /** Path of magnetic field model file.*/
         string magneticfield;
         /** Path of atmospheric model file.*/
         string atmosphere;
         /** Path of gravity field model file.*/
         string gravityfield;
         /** Propagation start epoch.*/
         double inittime;
         /** Variable to check if the first integration step has been executed.*/
         bool integ_first_step;
         /** boost odeint stepper for integrator. @see Method DynModel.*/
         bulirsch_stoer<state_type> bulirsch_stoer_stepper;
         };

   }; // End of namespace propagator

#endif
